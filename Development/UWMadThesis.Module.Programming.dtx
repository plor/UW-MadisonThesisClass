%<*UserGuide>
\section{Programming}\label{UG:Programming}
The Programming Module has no immediate user-facing features.
The Implementation section for this module outlines the programming layer
and is aimed mainly at authors that wish to utilize its abilities.

%</UserGuide>
%
%
%
%<*Documentation>
%<<Verbatim
%   \iffalse
%<*Code>
%   \fi
%
%^^A
%^^A  Module Name: Programming
%^^A  Author:
%^^A    Name:           Troy C. Haskin
%^^A    E-mail:         UWMadThesis@hask.in
%^^A  Version:
%^^A    Number:         1.0
%^^A    Description:    Initial release
%^^A    Date:           06/01/2013
%^^A  Purpose:
%^^A    Provide a programming layer for the UW-Madison Thesis package
%^^A    Most of the module is designed to overcome the lack of such a
%^^A    layer in LaTeX2e.  Some LaTeX3 is being used for certain advanced
%^^A    features, and this module may become obsolete when/if it is upgraded
%^^A    to a pure LaTeX3 implementation; though a thin abatraction layer may
%^^A    still be desired.
%
%   \Module{Programming}\label{Chapter:Programming}
%   This section outlines the Programming module for the \UWMadClassName{}.
%   It is mostly a collection of utility macros used in other modules.
%   The two biggest features in this module are the Array and Hash 
%   (associative arrays) systems used a other modules.  Those features 
%   are near the end of this subsection.
%
%   The commands are currently a mix of \TeX{}, \LaTeX2e{}, and \LaTeX3{}.
%   Pure \TeX{} is used only where the other features have no such facility
%   for the intended purpose.  Also, the |etoolbox| package is used as
%   the basis for many of the utility macros, and those macros are actually,
%   for all intents and purposes, just aliases for etoolbox commands. This
%   method was chosen to allow for an easier transition to another system.
%
%
%
%^^A ==================================================================== %
%^^A                        Core Programming Systems                      %
%^^A ==================================================================== %
%   \subsection{Core Programming Systems}
%
%   The commands in this section form the core of the programming module.
%   All of the Core systems are written using the \LaTeXPL and have 
%   extremely long names.  Most of the commands as thin abstractions from
%   the already-written \LaTeXPL modules and are designed to provide
%   a more stream-lined and robust environment in providing
%   useful warnings and errors where needed.
%
%   One of the main features added by the core programming system is more
%   transparent local-global handling.  The onus of remembering which
%   vairables of local-global is all that's needed with the commands
%   for altering them being all of the same.
%
%
%   We define some messages for the rest of the module.
%    \begin{macrocode}
\msg_new:nnn {UWMadThesis} {Programming/UnregisteredVariable} {
    `#1'~is~not~a~registered~#2.~~The~#2~must~be~defined~
    before~usage~by~the~function~\string\UWMad_#2_DefineLocal:n~or~
    \string\UWMad_#2_DefineGlobal:n.
}
\msg_new:nnn {UWMadThesis} {Programming/Undefined} {
    The~#2~`#1'~is~undefined.~~The~#2~must~be~defined~
    before~usage~by~the~function~\string\UWMad_#2_Define:n.
}
\msg_new:nnn {UWMadThesis} {Programming/Defined} {
    The~#2~`#1'~is~already~defined~and~will~not~altered.
}
%    \end{macrocode}
%
%
%   \begin{macro}{\__UWMad_IfLocal:nnnTF}
%   Certain subsystems of the Programming Module make a distinction
%   between local and global variables where scope is determined by
%   \TeX{} groups.  This command takes five arguments designed to 
%   increase maintainability and readability in the subsystems that
%   use it.
%
%   This command accepts a \marg{Prefix}, an \marg{ID}, a \marg{Type},
%   \marg{LocalCode}, and \marg{GlobalCode}.  All subsystems that use
%   this command have (in theory) already defined a command that concatenates
%   the \marg{Prefix}, \marg{ID}, and |_Local| or |_Global|
%   of a specific \marg{Type}.  If either of the commands is defined, the
%   appropriate code is executed (in an fully expandable fashion, which is
%   used to reduce code duplication where possible).  If neither of those
%   commands exist, the variable is not registered with the system and an
%   exception is thrown.
%
%   As an example, the counter system below creates a command by concatenating
%   |g__UWMad_Counter_| (the \marg{Prefix}) with user supplied \marg{ID} and 
%   either |_Local| or |_Global| depending on the definition.  That command is
%   a variable of \marg{Type} Counter.
%   |\__UWMad_IfLocal:nnnnn| handles the local-global branching.
%
%   \begin{Usage}
%       \item |\__UWMad_IfLocal:nnnTF| \marg{Prefix}\marg{ID}\marg{Type}
%                               \marg{LocalCode}, and \marg{GLobalCode}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_IfLocal:nnnTF {
    \cs_if_exist:cTF     {#1#2_Local}{
        #4
    }{
        \cs_if_exist:cTF {#1#2_Global}{
            #5
        }{
            \msg_error:nnnn
                {UWMadThesis}
                {Programming/UnregisteredVariable}
                {#2}
                {#3}
        }
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}[internal]{
%       \__UWMad_IfDefined:nnnnT,
%       \__UWMad_IfUndefined:nnnnT}
%   These commands accept a \marg{Prefix}, an \marg{ID}, a \marg{Suffix}
%   a \marg{Type}, and \marg{Code}.  It determines if a command named by the
%   concatenation of \marg{Prefix}, \marg{ID}, and \marg{Suffix}
%   is defined or not and executes \marg{Code} depending on the existence.
%
%   \begin{Usage}
%       \item |\__UWMad_IfUndefined:nnnnT| 
%           \marg{Prefix}\marg{ID}\marg{Suffix}\marg{Type}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_IfDefined:nnnnT{
    \cs_if_exist:cTF {#1#2#3} {
        #5
    }{
            \msg_error:nnnn
                {UWMadThesis}
                {Programming/Undefined}
                {#2}
                {#4}
    }
}
\cs_new:Nn \__UWMad_IfUndefined:nnnnT{
    \cs_if_free:cTF {#1#2#3} {
        #5
    }{
            \msg_warning:nnnn
                {UWMadThesis}
                {Programming/Defined}
                {#2}
                {#4}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Boolean System                            %
%^^A ==================================================================== %
%
%   \subsubsection{Boolean System}
%   This subsystem was made to give a \LaTeX{}-like branching system that
%   can create both local and global switches.
%
%   The system is a thin abstraction of
%   \LaTeXPL's |bool| module in the |l3prg| package to avoid developing
%   a one-shot system while allowing more endeavouring authors access to
%   to the simple feature without learning \LaTeX3{} programming.
%
%
%
%   \begin{function}{
%       \__UWMad_Boolean_IfLocal:nTF,
%       \__UWMad_Boolean_IfUndefined:nnT}
%   These commands are shortcuts to the more general commands
%   outlined above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_Boolean_IfLocal:nTF {
    \__UWMad_IfLocal:nnnTF
        {g__UWMad_Boolean_}{#1}{Boolean}{#2}{#3}
}
\cs_new:Nn \__UWMad_Boolean_IfUndefined:nnT{
    \__UWMad_IfUndefined:nnnnT
        {g__UWMad_Boolean_}{#1}{#2}{Boolean}{#3}
}
%    \end{macrocode}
%   \end{function}
%
%
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Boolean_DefineLocal:n {
    \__UWMad_Boolean_IfUndefined:nnT {#1} {_Local} {
        \bool_new:c {g__UWMad_Boolean_#1_Local}
    }
}
\cs_new:Nn \UWMad_Boolean_DefineGlobal:n {
    \__UWMad_Boolean_IfUndefined:nnT {#1} {_Global} {
        \bool_new:c {g__UWMad_Boolean_#1_Global}
    }
}
%
%
%
\cs_new:Nn \UWMad_Boolean_DefineLocalSetTrue:n {
    \__UWMad_Boolean_IfUndefined:nnT {#1} {_Local} {
        \bool_new:c       {g__UWMad_Boolean_#1_Local}
        \bool_gset_true:c {g__UWMad_Boolean_#1_Local}
    }
}
\cs_new:Nn \UWMad_Boolean_DefineLocalSetFalse:n {
    \__UWMad_Boolean_IfUndefined:nnT {#1} {_Local} {
        \bool_new:c        {g__UWMad_Boolean_#1_Local}
        \bool_gset_false:c {g__UWMad_Boolean_#1_Local}
    }
}
%
%
%
\cs_new:Nn \UWMad_Boolean_DefineGlobalSetTrue:n {
    \__UWMad_Boolean_IfUndefined:nnT {#1} {_Global} {
        \bool_new:c       {g__UWMad_Boolean_#1_Global}
        \bool_gset_true:c {g__UWMad_Boolean_#1_Global}
    }
}
\cs_new:Nn \UWMad_Boolean_DefineGlobalSetFalse:n {
    \__UWMad_Boolean_IfUndefined:nnT {#1} {_Global} {
        \bool_new:c        {g__UWMad_Boolean_#1_Global}
        \bool_gset_false:c {g__UWMad_Boolean_#1_Global}
    }
}
%
%
%
\cs_new:Nn \UWMad_Boolean_SetTrue:n {
    \__UWMad_Boolean_IfLocal:nTF {#1} {
        \bool_set_true:c  {g__UWMad_Boolean_#1_Local}
    }{
        \bool_gset_true:c {g__UWMad_Boolean_#1_Global}
    }
}
\cs_new:Nn \UWMad_Boolean_SetFalse:n {
    \__UWMad_Boolean_IfLocal:nTF {#1} {
        \bool_set_false:c  {g__UWMad_Boolean_#1_Local}
    }{
        \bool_gset_false:c {g__UWMad_Boolean_#1_Global}
    }
}
%
%
%
\cs_new:Nn \UWMad_Boolean_IfTrue:nTF {
    \__UWMad_Boolean_IfLocal:nTF {#1} {
        \bool_if:cTF {g__UWMad_Boolean_#1_Local}
    }{
        \bool_if:cTF {g__UWMad_Boolean_#1_Global}
    }
    {#2}
    {#3}
}
\cs_new:Nn \UWMad_Boolean_IfFalse:nTF {
    \__UWMad_Boolean_IfLocal:nTF {#1} {
        \bool_if:cTF {g__UWMad_Boolean_#1_Local}
    }{
        \bool_if:cTF {g__UWMad_Boolean_#1_Global}
    }
    {#3}
    {#2}
}
%    \end{macrocode}
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Length System                             %
%^^A ==================================================================== %
%
%   \subsubsection{Length System}
%   This subsystem was made to give a \LaTeX{}-like length system that
%   can create both local and global lengths.
%
%   The system is a thin abstraction of
%   \LaTeXPL's |dim| module in the |l3skip| package to avoid developing
%   a one-shot system while allowing more endeavouring authors access to
%   to the simple feature without learning \LaTeX3{} programming.
%
%
%
%   \begin{macro}[internal]{
%       \__UWMad_Length_IfLocal:nTF,
%       \__UWMad_Length_IfUndefined:nnT}
%   These commands are shortcuts to the more general 
%   commands outlines above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_Length_IfLocal:nTF {
    \__UWMad_IfLocal:nnnTF
        {g__UWMad_Length_}{#1}{Length}{#2}{#3}
}
\cs_new:Nn \__UWMad_Length_IfUndefined:nnT{
    \__UWMad_IfUndefined:nnnnT{g__UWMad_Length_}{#1}{#2}{Length}{#3}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Length_DefineLocal:nn {
    \__UWMad_Length_IfUndefined:nnT {#1} {_Local} {
        \dim_new:c   {g__UWMad_Length_#1_Local}
        \dim_gset:cn {g__UWMad_Length_#1_Local} {#2}
    }
}
\cs_new:Nn \UWMad_Length_DefineGlobal:nn {
    \__UWMad_Length_IfUndefined:nnT {#1} {_Global} {
        \dim_new:c   {g__UWMad_Length_#1_Global}
        \dim_gset:cn {g__UWMad_Length_#1_Global} {#2}
    }
}
%
%
%
\cs_new:Nn \UWMad_Length_Add:nn {
    \__UWMad_Length_IfLocal:nTF {#1} {
        \dim_add:cn  {g__UWMad_Length_#1_Local}  {#2}
    }{
        \dim_gadd:cn {g__UWMad_Length_#1_Global} {#2}
    }
}
%
%
%
\cs_new:Nn \UWMad_Length_Set:nn {
    \__UWMad_Length_IfLocal:nTF {#1} {
        \dim_set:cn  {g__UWMad_Length_#1_Local}  {#2}
    }{
        \dim_gset:cn {g__UWMad_Length_#1_Global} {#2}
    }
}
%
%
%
\cs_new:Nn \UWMad_Length_Of:n {
    \__UWMad_Length_IfLocal:nTF {#1} {
        \dim_use:c {g__UWMad_Length_#1_Local}
    }{
        \dim_use:c {g__UWMad_Length_#1_Global}
    }
}
%
%
%
\cs_new:Nn \UWMad_Length_If:nnnTF {
    \dim_compare:nTF{ \UWMad_Length_Of:n{#1} #2 #3 }{
        #4
    }{
        #5
    }
}
%    \end{macrocode}
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Counter System                            %
%^^A ==================================================================== %
%
%   \subsubsection{Counter System}
%   This subsystem was made to give a \LaTeX{}-like counter system that
%   can create both local and global counters.
%
%
%   \begin{macro}[internal]{
%       \__UWMad_Counter_IfLocal:nTF,
%       \__UWMad_Counter_IfUndefined:nTF}
%   These commands are shortcuts to the more general 
%   commands outlines above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_Counter_IfLocal:nTF {
    \__UWMad_IfLocal:nnnTF
        {g__UWMad_Counter_}{#1}{Counter}{#2}{#3}
}
\cs_new:Nn \__UWMad_Counter_IfUndefined:nnT{
    \__UWMad_IfUndefined:nnnnT{g__UWMad_Counter_}{#1}{#2}{Counter}{#3}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{
%       \UWMad_Counter_DefineLocal:nn,
%       \UWMad_Counter_DefineGlobal:nn}
%   This pair creates either a local or global counter named
%   \marg{Counter Name} with \marg{Initial Value}. The counters
%   are registered, defined to be local or global, initialized
%   by |\newcount|, and set to \marg{Initial Value}.
%
%   \begin{Usage}
%       \item |\DefineNewLocalCounter|\marg{Counter Name}{Initial Value}
%       \item |\DefineNewGlobalCounter|\marg{Counter Name}{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Counter_DefineLocal:nn {
    \__UWMad_Counter_IfUndefined:nnT {#1} {_Local} {
        \int_new:c   {g__UWMad_Counter_#1_Local}
        \int_gset:cn {g__UWMad_Counter_#1_Local} {#2}
    }
}
\cs_new:Nn \UWMad_Counter_DefineGlobal:nn {
    \__UWMad_Counter_IfUndefined:nnT {#1} {Global} {
        \int_new:c   {g__UWMad_Counter_#1_Global}
        \int_gset:cn {g__UWMad_Counter_#1_Global} {#2}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\UWMad_Counter_Add:nn}
%   This command adds \marg{Increment} to the current value of counter
%   \marg{CounterName}. Local vs. global advancement is set at definition
%   and is handled transparently.
%
%   \begin{Usage}
%       \item |\AddToCounter|\marg{CounterName}\marg{Increment}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Counter_Add:nn {
    \__UWMad_Counter_IfLocal:nTF {#1} {
        \int_add:cn  {g__UWMad_Counter_#1_Local}  {#2}
    }{
        \int_gadd:cn {g__UWMad_Counter_#1_Global} {#2}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\UWMad_Counter_Step:n}
%   Adds $1$ to the counter \marg{Counter Name}.
%   |\UWMad_IsLocal:nnn| handles the local vs. global advancement.
%
%   \begin{Usage}
%       \item |\UWMad_Counter_Step:nn|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Counter_Step:n {
    \UWMad_Counter_Add:nn{#1}{1}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\UWMad_Counter_Set:nn}
%   This command sets the value of counter \marg{Counter Name} to \marg{Value}.
%   |\UWMad_IsLocal:nnn| handles the local vs. global assignment.
%
%   \begin{Usage}
%       \item |\SetCounter|\marg{Counter Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Counter_Set:nn {
    \__UWMad_Counter_IfLocal:nTF {#1} {
        \int_set:cn  {g__UWMad_Counter_#1_Local}  {#2}
    }{
        \int_gset:cn {g__UWMad_Counter_#1_Global} {#2}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{
%       \UWMad_Counter_SetAndAdd:nnn,
%       \UWMad_Counter_SetAndStep:nn}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%
%   \begin{Usage}
%       \item |\SetAndAddToCounter|\marg{Counter Name}\marg{Initial Value}\marg{Value}
%       \item |\SetAndStepCounter|\marg{Counter Name}\marg{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Counter_SetAndAdd:nnn {
    \UWMad_Counter_Set:nn{#1}{#2}
    \UWMad_Counter_Add:nn{#1}{#3}
}
\cs_new:Nn \UWMad_Counter_SetAndStep:nn {
    \UWMad_Counter_SetAndAdd:nnn {#1}{#2}{1}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\UWMad_Counter_Value:n}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%
%   \begin{Usage}
%       \item |\CounterValue|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Counter_Value:n {
    \__UWMad_Counter_IfLocal:nTF {#1} {
        \int_use:c {g__UWMad_Counter_#1_Local}
    }{
        \int_use:c {g__UWMad_Counter_#1_Global}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\UWMad_Counter_Compare:nnnTF}
%
%   \begin{Usage}
%       \item |\UWMad_Counter_Compare:nnnTF| {}{}{}{}{}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Counter_Compare:nnnTF {
    \int_compare:nTF {\UWMad_Counter_Value:n{#1} #2 #3} {
        #4
    }{
        #5
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%
%^^A ======================================================================= %
%^^A                          CSV Creation Commands                          %
%^^A ======================================================================= %
%
%   \subsubsection{CSV System}
%   This set of commands is a simple system for comma-separated value (CSV)
%   list creation.  It consists of only a few functions: initialize list,
%   append value, prepend value, get list, and erase list.
%
%   This feature was created solely to export |hyperref| meta-data to an
%   external file for later reading.  The system is a thin abstraction of
%   \LaTeXPL's |l3clist| package to avoid developing
%   a one-shot system while allowing more endeavouring authors access to
%   to the simple feature without learning \LaTeX3{} programming.
%
%
%   \begin{macro}[internal]{
%       \__UWMad_CSV_IfDefined:nT,
%       \__UWMad_CSV_IfUndefined:nT}
%   Shortcuts for the more general commands outlined above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_CSV_IfDefined:nT {
    \__UWMad_IfDefined:nnnnT{g__UWMad_CSV_}{#1}{}{CSV}{#2}
}
\cs_new:Nn \__UWMad_CSV_IfUndefined:nT{
    \__UWMad_IfUndefined:nnnnT{g__UWMad_CSV_}{#1}{}{CSV}{#2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_CSV_Define:n {
    \__UWMad_CSV_IfUndefined:nT {#1} {
        \clist_new:c {g__UWMad_CSV_#1}
    }
}
%
%
\cs_new:Nn \UWMad_CSV_Clear:n {
    \__UWMad_CSV_IfDefined:nT {#1} {
        \clist_gclear:c {g__UWMad_CSV_#1}
    }
}
%
%
\cs_new:Nn \UWMad_CSV_Delete:n {
    \__UWMad_CSV_IfDefined:nT {#1} {
        \clist_gclear:c {g__UWMad_CSV_#1}
        \cs_undefine:c  {g__UWMad_CSV_#1}
    }
}
%
%
\cs_new:Nn \UWMad_CSV_Append:nn {
    \__UWMad_CSV_IfDefined:nT {#1} {
        \clist_gput_right:cn {g__UWMad_CSV_#1} {#2}
    }
}
%
%
\cs_new:Nn \UWMad_CSV_Prepend:nn {
    \__UWMad_CSV_IfDefined:nT {#1} {
        \clist_gput_left:cn {g__UWMad_CSV_#1} {#2}
    }
}
%
%
\cs_new:Nn \UWMad_CSV_Get:n {
    \__UWMad_CSV_IfDefined:nT {#1} {
        \use:c {g__UWMad_CSV_#1}
    }
}
%
%
\cs_new:Nn \UWMad_CSV_IfNotEmpty:nTF {
    \__UWMad_CSV_IfDefined:nT {#1} {
        \clist_if_empty:cTF {g__UWMad_CSV_#1} {
            #3
        }{
            #2
        }
    }
}
%    \end{macrocode}
%
%
%
%
%
%%^^A ======================================================================= %
%%^^A                     Collection Creation Commands                        %
%%^^A ======================================================================= %
%%
%%   \subsubsection{Collections}
%%   In the following subsections, commands that create and manipulate
%%   various collection data types will be discussed.  The collections
%%   currently implemented are stacks (LIFO), queues (FIFO), and deques
%%   (LIFO+FIFO).
%%
%%   All of the collection systems are thin abstractions of \LaTeXPL's
%%   |l3seq| module to avoid developing one-shot systems while allowing more
%%   endeavoring authors access to the features without learning \LaTeX3{}
%%   programming.
%
%
%
%^^A ======================================================================= %
%^^A                          Stack Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsubsection{Stack System}
%   This set of commands is a simple system for creating and working with
%   stacks.  Stacks are a last-in first-out collection data type; this means
%   that the data element (in this any unexpanded token/token list) last 
%   pushed on to the stack is the first popped.  Data elements can also be
%   walked (iterated over) with an inline callback in a LIFO sense.
%
%
%
%   \begin{macro}[internal]{
%       \__UWMad_Stack_IfDefined:nT,
%       \__UWMad_Stack_IfUndefined:nT}
%   Shortcuts for the more general commands outlined above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_Stack_IfDefined:nT {
    \__UWMad_IfDefined:nnnnT{g__UWMad_Stack_}{#1}{}{Stack}{#2}
}
\cs_new:Nn \__UWMad_Stack_IfUndefined:nT{
    \__UWMad_IfUndefined:nnnnT{g__UWMad_Stack_}{#1}{}{Stack}{#2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Stack_Define:n {
    \__UWMad_Stack_IfUndefined:nT {#1} {
        \tl_new:c {g__UWMad_Stack_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Stack_Clear:n {
    \__UWMad_Stack_IfDefined:nT {#1} {
        \tl_gclear:c   {g__UWMad_Stack_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Stack_Delete:n {
    \__UWMad_Stack_IfDefined:nT {#1} {
        \tl_gclear:c   {g__UWMad_Stack_#1}
        \cs_undefine:c {g__UWMad_Stack_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Stack_Push:nn {
    \__UWMad_Stack_IfDefined:nT {#1} {
        \tl_gput_left:cn {g__UWMad_Stack_#1} {#2}
    }
}
%
%
\cs_generate_variant:Nn \tl_head:N { c }
\cs_generate_variant:Nn \tl_tail:N { c }
%
\cs_new:Nn \UWMad_Stack_Pop:n {
    \__UWMad_Stack_IfDefined:nT {#1} {
        \tl_set:Nx \l_tmpa_tl          {\tl_head:c {g__UWMad_Stack_#1}}
        \tl_set:cx {g__UWMad_Stack_#1} {\tl_tail:c {g__UWMad_Stack_#1}}
        \tl_use:N \l_tmpa_tl
    }
}
%
%
\cs_new:Nn \UWMad_Stack_Walk:nn {
    \tl_map_inline:cn {g__UWMad_Stack_#1} {#2}
}
%    \end{macrocode}
%
%
%
%^^A ======================================================================= %
%^^A                          Queue Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsubsection{Queue System}
%   This set of commands is a simple system for creating and working with
%   queue.  Queues are a first-in first-out collection data type; this means
%   that the data element (in this any unexpanded token/token list) first 
%   pushed on to the queue is the first popped.  Data elements can also be
%   walked (iterated over) with an inline callback in a FIFO sense.
%
%
%
%   \begin{macro}[internal]{
%       \__UWMad_Queue_IfDefined:nT,
%       \__UWMad_Queue_IfUndefined:nT}
%   Shortcuts for the more general commands outlined above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_Queue_IfDefined:nT {
    \__UWMad_IfDefined:nnnnT{g__UWMad_Queue_}{#1}{}{Queue}{#2}
}
\cs_new:Nn \__UWMad_Queue_IfUndefined:nT{
    \__UWMad_IfUndefined:nnnnT{g__UWMad_Queue_}{#1}{}{Queue}{#2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Queue_Define:n {
    \__UWMad_Queue_IfUndefined:nT {#1} {
        \tl_new:c {g__UWMad_Queue_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Queue_Delete:n {
    \__UWMad_Queue_IfDefined:nT {#1} {
        \tl_gclear:c    {g__UWMad_Queue_#1}
         \cs_undefine:c {g__UWMad_Queue_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Queue_Clear:n {
    \__UWMad_Queue_IfDefined:nT {#1} {
        \tl_gclear:c {g__UWMad_Queue_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Queue_Push:nn {
    \__UWMad_Queue_IfDefined:nT {#1} {
        \tl_gput_left:cn {g__UWMad_Queue_#1} {{#2}}
    }
}
%
%
\cs_generate_variant:Nn \tl_head:N { c }
\cs_generate_variant:Nn \tl_tail:N { c }
%
\cs_new:Nn \UWMad_Queue_Pop:n {
    \__UWMad_Queue_IfDefined:nT {#1} {
        \tl_reverse:c   {g__UWMad_Queue_#1}
        \tl_set:Nx \l_tmpa_tl
            {\tl_head:c {g__UWMad_Queue_#1}}
        \tl_set:cx      {g__UWMad_Queue_#1}
            {\tl_tail:c {g__UWMad_Queue_#1}}
        \tl_reverse:c   {g__UWMad_Queue_#1}
        \tl_use:N \l_tmpa_tl
    }
}
%
%
\cs_new:Nn \UWMad_Queue_Walk:nn {
    \__UWMad_Queue_IfDefined:nT {#1} {
        \group_begin:
            \tl_reverse:c     {g__UWMad_Queue_#1}
            \tl_map_inline:cn {g__UWMad_Queue_#1} {#2}
        \group_end:
    }
}
%
%
\cs_new:Nn \UWMad_Queue_IfEmpty:nTF {
    \__UWMad_Queue_IfDefined:nT {#1} {
        \tl_if_empty:cTF {g__UWMad_Queue_#1}{
            #2
        }{
            #3
        }
    }
}
%    \end{macrocode}
%
%
%^^A ======================================================================= %
%^^A                          Deque Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsubsection{Deque System}
%   This set of commands is a simple system for creating and working with
%   double-ended queues (deques, pronounced \textit{deck}).  Deques are a
%   generalization of stacks and queues in that data can be pushed, popped,
%   and walked from either end of the list (i.e., LIFO+FIFO).
%
%
%
%   \begin{macro}[internal]{
%       \__UWMad_Deque_IfDefined:nT,
%       \__UWMad_Deque_IfUndefined:nT}
%   Shortcuts for the more general  commands outlined above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_Deque_IfDefined:nT {
    \__UWMad_IfDefined:nnnnT{g__UWMad_Deque_}{#1}{}{Deque}{#2}
}
\cs_new:Nn \__UWMad_Deque_IfUndefined:nT{
    \__UWMad_IfUndefined:nnnnT{g__UWMad_Deque_}{#1}{}{Deque}{#2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Deque_Define:n {
    \__UWMad_Deque_IfUndefined:nT {#1} {
        \seq_new:c {g__UWMad_Deque_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Deque_Delete:n {
    \__UWMad_Deque_IfDefined:nT {#1} {
        \seq_gclear:c  {g__UWMad_Deque_#1}
        \cs_undefine:c {g__UWMad_Deque_#1}
    }
}
%
%
\cs_new:Nn \UWMad_Deque_PushLeft:nn {
    \__UWMad_Deque_IfDefined:nT {#1} {
        \seq_gput_left:cn  {g__UWMad_Deque_#1} {#2}
    }
}
\cs_new:Nn \UWMad_Deque_PushRight:nn {
    \__UWMad_Deque_IfDefined:nT {#1} {
        \seq_gput_right:cn {g__UWMad_Deque_#1} {#2}
    }
}
%
%
\cs_new:Nn \UWMad_Deque_PopLeft:n {
    \__UWMad_Deque_IfDefined:nT {#1} {
        \seq_gpop_left:cN  {g__UWMad_Deque_#1} \l_tmpa_tl
        \tl_use:N \l_tmpa_tl
    }
}
\cs_new:Nn \UWMad_Deque_PopRight:n {
    \__UWMad_Deque_IfDefined:nT {#1} {
        \seq_gpop_right:cN {g__UWMad_Deque_#1} \l_tmpa_tl
        \tl_use:N \l_tmpa_tl
    }
}
%
%
\cs_new:Nn \UWMad_Deque_WalkLeftToRight:nn {
    \__UWMad_Deque_IfDefined:nT {#1} {
        \seq_map_inline:cn {g__UWMad_Deque_#1} {#2}
    }
}
%
%
\cs_generate_variant:Nn \seq_reverse:N {c}
\cs_new:Nn \UWMad_Deque_WalkRightToLeft:nn {
    \__UWMad_Deque_IfDefined:nT {#1} {
        \group_begin:
            \seq_reverse:c     {g__UWMad_Deque_#1}
            \seq_map_inline:cn {g__UWMad_Deque_#1} {#2}
        \group_end:
    }
}
%    \end{macrocode}
%
%
%
%
%
%^^A =========================================================================== %
%^^A                 Hashes (Associative Arrays) with LaTeX3                     %
%^^A =========================================================================== %
%
%   \subsubsection{Hash System}
%   This set of commands is a simple system for creating and working with
%   hashes (more often called associative arrays or dictionaries, but erring
%   on the side of usablility, Ruby's jargon will be used). Hashes are a
%   type of array that indexes values by (at least in \LaTeX{}) alphanumeric
%   keys instead of just integers.
%   Data can be set by key, retrieved by key, unset by key, deleted, and walked.
%
%   A hash walk, like the collection walks above, iterates through all of the
%   keys and values in the hash while applying a user supplied function.
%   However, unlike the collection walks, \textbf{a hash's walk order is not
%   gauranteed to be the set order}.  If walk order is needed to be
%   gauranteed, see the previous collection data types.
%
%   The system is a thin abstraction of \LaTeXPL's
%   |l3prop| module to avoid developing a one-shot system while allowing more
%   endeavoring authors access to the feature without learning \LaTeX3{}
%   programming.
%
%
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_gput:Nnn   { c x n   }
\cs_generate_variant:Nn \prop_if_in:NnTF { c x TF  }
\cs_generate_variant:Nn \prop_if_in:NnTF { c f TF  }
\cs_generate_variant:Nn \prop_get:Nn     { c x     }
\cs_generate_variant:Nn \prop_get:Nn     { c f     }
\cs_generate_variant:Nn \prop_get:NnNTF  { c x N TF}
\cs_generate_variant:Nn \prop_gremove:Nn { c x     }
%    \end{macrocode}
%
%
%   \begin{macro}[internal]{
%       \__UWMad_Hash_IfDefined:nT,
%       \__UWMad_Hash_IfUndefined:nT}
%   Shortcuts for the more general commands outlined above.
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_Hash_IfDefined:nT {
    \__UWMad_IfDefined:nnnnT{g__UWMad_Hash_}{#1}{}{Hash}{#2}
}
\cs_new:Nn \__UWMad_Hash_IfUndefined:nT{
    \__UWMad_IfUndefined:nnnnT{g__UWMad_Hash_}{#1}{}{Hash}{#2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_Hash_Define:n {
    \__UWMad_Hash_IfUndefined:nT {#1} {
        \prop_new:c {g__UWMad_Hash_#1}
    }
}

\cs_new:Nn \UWMad_Hash_Set:nnn {
    \__UWMad_Hash_IfDefined:nT {#1} {
        \prop_gput:cxn {g__UWMad_Hash_#1}{#2}{#3}
    }
}

\cs_new:Nn \UWMad_Hash_Get:nn {
    \__UWMad_Hash_IfDefined:nT {#1} {
        \prop_get:cxNTF {g__UWMad_Hash_#1} {#2} \l_tmpa_prop {
            \tl_use:N \l_tmpa_prop
        }
    }
}

\cs_generate_variant:Nn \prop_get:cn {cf}

\cs_new:Nn \UWMad_Hash_ExpandableGet:nn {
    \__UWMad_Hash_IfDefined:nT {#1} {
        \prop_get:cf {g__UWMad_Hash_#1}{#2}
    }
}

\cs_new:Nn \UWMad_Hash_Unset:nn {
    \__UWMad_Hash_IfDefined:nT {#1} {
        \prop_gremove:cx {g__UWMad_Hash_#1} {#2}
    }
}

\cs_generate_variant:Nn \tl_to_lowercase:n {f}

\cs_new:Nn \UWMad_Hash_IfKeySet:nnTF {
    \__UWMad_Hash_IfDefined:nT {#1} {
        \prop_if_in:cfTF {g__UWMad_Hash_#1} {\tl_trim_spaces:n{#2}} {
            #3
        }{
            #4
        }
    }
}

\cs_new:Nn \UWMad_Hash_Walk:nn {
    \__UWMad_Hash_IfDefined:nT {#1} {
        \prop_map_inline:cn {g__UWMad_Hash_#1} {#2}
    }
}

\cs_new:Nn \UWMad_Hash_Delete:n {
    \__UWMad_Hash_IfDefined:nT {#1} {
        \prop_gclear:c {g__UWMad_Hash_#1}
        \cs_undefine:c {g__UWMad_Hash_#1}
    }
}
%    \end{macrocode}
%
%
%
%
%^^A ==================================================================== %
%^^A                         LaTeX2e Abstractions                         %
%^^A ==================================================================== %
%
%   \subsection{\texorpdfstring{\LaTeXe{}}{LaTeX2e} Abstractions}
%
%   The commands that follow are \LaTeXe{}-like commands that use the
%   \LaTeXPL{} as the underlying system.  \textbf{The commands are not loaded
%   by default; they must be invoked by calling the following command.}
%
%   \begin{macro}{\LoadLaTeXeAbstractions}
%   \textbf{This command needs to be invoked to define the abstractions
%   for usage.}
%
%    \begin{macrocode}
\DeclareDocumentCommand \LoadLaTeXeAbstractions { } {
%    \end{macrocode}
%
%   \end{macro}
%
%   \subsubsection{Utility Commands}
%
%
%   \begin{macro}{\IfCommandExists,\IfCommandDoesNotExist}
%   This command pair is used instead of \LaTeX{}'s |\@ifundefined|.
%   Since it is \eTeX{}, this command will allow for a switch to
%   |\@ifundefined| if problems arise from non-\eTeX{} users in the
%   future.
%
%   \begin{Usage}
%       \item |\IfCommandExists|\marg{Command Name}\marg{True}\marg{False}
%       \item |\IfCommandDoesNotExist|\marg{Command Name}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfCommandExists { m +m +m }{
    \cs_if_exist:cTF {##1}{
        ##2
    }{
        ##3
    }
}
\DeclareDocumentCommand \IfCommandDoesNotExist { m +m +m }{
    \cs_if_free:cTF {##1}{
        ##2
    }{
        ##3
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfStringEmpty}
%   Checks if a given string is empty.
%   It uses the |etoolbox|'s |\ifblank|.
%   This command will not expand input.
%
%   \begin{Usage}
%       \item |\IfStringEmpty|\marg{String}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfStringEmpty { m +m +m }{
    \tl_if_blank:nTF {##1}{
        ##2
    }{
        ##3
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfCommandEmpty}
%   Uses the |etoolbox|'s |\ifdefempty| command to test if a command expands
%   to an empty string and is followed by the given conditional code.
%
%   \begin{Usage}
%       \item |IfCommandEmpty|\marg{Command}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfCommandEmpty { m +m +m }{
    \tl_if_blank:oTF{##1}{
        ##2
    }{
        ##3
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                      Command Creator System                          %
%^^A ==================================================================== %
%
%   \subsubsection{Command Creator System}
%
%   \begin{macro}{\MakeCommand,\ReMakeCommand}
%   This command pair uses the |etoolbox|'s |\csdef| to define a commands
%   via a supplied string \marg{Command Name} and a set of \marg{Code}.
%   If the requested command is not defined, |\MakeCommand| will create it;
%   however, if the requested command is already defined, |\MakeCommand| will
%   throw a warning and not make the command.
%   If the requested command is defined, |\ReMakeCommand| will redefine it;
%   however, if the requested command is not defined, |\ReMakeCommand| will
%   throw a warning and not make the command.
%
%   \begin{Usage}
%       \item |\MakeCommand|\marg{Command Name}\marg{Code}
%       \item |\ReMakeCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeCommand { m +m } {
    \cs_set:cpn {##1} {##2}
}
\DeclareDocumentCommand \ReMakeCommand { m +m }{
    \IfCommandExists{##1}{
        \cs_set:cpn {##1} {##2}
    }{
        \UWMad@ClassWarning{Command~`##1'~is~undefined.}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeGlobalCommand}
%   Similar to |\MakeCommand| except the creation is made regardless of the
%   requested command's definition and the creation is global.
%
%   \begin{Usage}
%       \item |\MakeGlobalCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeGlobalCommand { m +m } {
    \cs_gset:cpn {##1} {##2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeExpandedCommand}
%   This command creates a command in the spirit of |\MakeCommand|
%   but with several differences.  First, the command simply creates
%   the requested command without regard to its existence.  Secondly,
%   the \marg{Code} supplied is fully expanded without protection.
%   Lastly, the definitions are global.
%
%   \begin{Usage}
%       \item |\MakeExpandedCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeExpandedCommand { m +m } {
    \cs_get:cpx {##1} {##2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeCommandUndefined}
%   Globally undefines the command specified by \marg{Command Name}.
%
%   \begin{Usage}
%       \item |\MakeCommandUndefined|\marg{Command Name}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeCommandUndefined { m } {
    \cs_undefine:c {##1}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\CopyCommand}
%   Copies the defintion of the command named \marg{Command Name 1} to 
%   a new command named \marg{Command Name 2}.  If \marg{Command Name 2}
%   already has a definition, |\CopyCommand| will throw a warning
%   \emph{but} still make the copy.
%
%   \begin{Usage}
%       \item |\CopyCommand|\marg{Command Name 1}\marg{Command Name 2}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \CopyCommand { m m } {
    \IfCommandExists{##1} {
        \IfCommandExists{##2} {
            \UWMad@ClassWarning{Command~`##2'~is~defined.}
        }{
        }
        \cs_gset_eq:cc {##2}{##1}
    }{
        \UWMad@ClassWarning{Command~`##1'~is~undefined.}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%   \subsubsection{Core System Aliases}
%
%
%
%
%
%
%   This line closes the |\LoadLaTeXeAbstractions| command.
%    \begin{macrocode}
}
%    \end{macrocode}
%
%
%
%
%
%
%   \iffalse
%</Code>
%   \fi
%Verbatim
%</Documentation>