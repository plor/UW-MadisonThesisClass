%<*UserGuide>
\ifUWMad@UserGuide

\section{Programming}\label{UG:Programming}
The Programming Module has no immediate user-facing features.
The Implementation section for this module outlines the programming layer
and is aimed mainly at authors that wish to utilize its abilities.

\fi
%</UserGuide>
%
%
%
%<*Implementation>
%<<Verbatim
%<*Module:Programming>
%
%^^A
%^^A  Module Name: Programming
%^^A  Author:
%^^A    Name:           Troy C. Haskin
%^^A    E-mail:         UWMadThesis@hask.in
%^^A  Version:
%^^A    Number:         1.0
%^^A    Description:    Initial release
%^^A    Date:           06/01/2013
%^^A  Purpose:
%^^A    Provide a programming layer for the UW-Madison Thesis package
%^^A    Most of the module is designed to overcome the lack of such a
%^^A    layer in LaTeX2e.  Some LaTeX3 is being used for certain advanced
%^^A    features, and this module may become obsolete when/if it is upgraded
%^^A    to a pure LaTeX3 implementation; though a thin abatraction layer may
%^^A    still be desired.
%
%   \section{Programming Module}\label{Imp:Programming}
%   This section outlines the Programming module for the \UWMadClass.
%   It is mostly a collection of utility macros used in other modules.
%   The two biggest features in this module are the Array and Hash 
%   (associative arrays) systems used a other modules.  Those features 
%   are near the end of this subsection.
%
%   The commands are currently a mix of \TeX{}, \LaTeX2e{}, and \LaTeX3{}.
%   Pure \TeX{} is used only where the other features have no such facility
%   for the intended purpose.  Also, the |etoolbox| package is used as
%   the basis for many of the utility macros, and those macros are actually,
%   for all intents and purposes, just aliases for etoolbox commands. This
%   method was chosen to allow for an easier transition to another system.
%
%
%^^A ==================================================================== %
%^^A                            Utility Macros                            %
%^^A ==================================================================== %
%
%   \subsection{Utility Macros}
%
%   \begin{macro}{\GlobalNewIf}
%   Changes to if-switches only have block level scope by default.
%   Therefore, switches generated by |\newif| revert to their pre-block
%   state upon exiting a scope regardless of any non-global changes within
%   the block.  This command creates an if-switch pair that has inherent
%   global scope.
%
%   \begin{Usage}
%       \item |\GlobalNewIf|\marg{SwitchName}
%   \end{Usage}
%
%    \begin{macrocode}
\ExplSyntaxOn
\DeclareDocumentCommand \GlobalNewIf { m }{
    \cs_gset_eq:cc {if#1} {iftrue}
    \cs_gset_nopar:cpn {#1true}{
        \cs_gset_eq:cc {if#1} {iftrue}
    }
    \cs_gset_nopar:cpn {#1false}{
        \cs_gset_eq:cc {if#1} {iffalse}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfCommandExists}
%   \begin{macro}{\IfCommandDoesNotExist}
%   This command pair is used instead of \LaTeX{}'s |\@ifundefined|.
%   Since it is \eTeX{}, this command will allow for a switch to
%   |\@ifundefined| if problems arise from non-\eTeX{} users in the
%   future.
%
%   \begin{Usage}
%       \item |\IfCommandExists|\marg{Command Name}\marg{True}\marg{False}
%       \item |\IfCommandDoesNotExist|\marg{Command Name}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfCommandExists { m +m +m }{
    \cs_if_exist:cTF {#1}{
        #2
    }{
        #3
    }
}
\DeclareDocumentCommand \IfCommandDoesNotExist { m +m +m }{
    \cs_if_free:cTF {#1}{
        #2
    }{
        #3
    }
}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfStringEmpty}
%   Checks if a given string is empty.
%   It uses the |etoolbox|'s |\ifblank|.
%   This command will not expand input.
%
%   \begin{Usage}
%       \item |\IfStringEmpty|\marg{String}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfStringEmpty { m +m +m }{
    \tl_if_blank:nTF {#1}{
        #2
    }{
        #3
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfCommandEmpty}
%   Uses the |etoolbox|'s |\ifdefempty| command to test if a command expands
%   to an empty string and is followed by the given conditional code.
%
%   \begin{Usage}
%       \item |IfCommandEmpty|\marg{Command}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfCommandEmpty { m +m +m }{
    \tl_if_blank:oTF{#1}{
        #2
    }{
        #3
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewLength}
%   This is a convenience command used to define a new length
%   \marg{Length Name} and set its \marg{Value}.
%
%   \begin{Usage}
%       \item |DefineNewLength|\marg{Length Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\DefineNewLength}[2]{
    \newlength{#1}
    \setlength{#1}{#2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewCounter}
%   This is a convenience command used to define a new \LaTeX{} counter
%   \marg{Counter Name} and set its \marg{Value}.
%
%   \begin{Usage}
%       \item |DefineNewCounter|\marg{Counter Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\DefineNewCounter}[2]{
    \newcounter{#1}
    \setcounter{#1}{#2}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                      Command Creator System                          %
%^^A ==================================================================== %
%
%   \subsection{Command Creator System}
%
%   \begin{macro}{\MakeCommand}
%   \begin{macro}{\ReMakeCommand}
%   This command pair uses the |etoolbox|'s |\csdef| to define a commands
%   via a supplied string \marg{Command Name} and a set of \marg{Code}.
%   If the requested command is not defined, |\MakeCommand| will create it;
%   however, if the requested command is already defined, |\MakeCommand| will
%   throw a warning and not make the command.
%   If the requested command is defined, |\ReMakeCommand| will redefine it;
%   however, if the requested command is not defined, |\ReMakeCommand| will
%   throw a warning and not make the command.
%
%   \begin{Usage}
%       \item |\MakeCommand|\marg{Command Name}\marg{Code}
%       \item |\ReMakeCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeCommand { m +m }
    {\cs_set:cpn {#1} {#2}}
\DeclareDocumentCommand \ReMakeCommand { m +m }
    {\IfCommandExists{#1}
        {\cs_set:cpn {#1} {#2}}
        {\UWMad@ClassWarning{Command~`#1'~is~undefined.}}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeGlobalCommand}
%   Similar to |\MakeCommand| except the creation is made regardless of the
%   requested command's definition and the creation is global.
%
%   \begin{Usage}
%       \item |\MakeGlobalCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeGlobalCommand { m +m }
    {\cs_gset:cpn {#1} {#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeExpandedCommand}
%   This command creates a command in the spirit of |\MakeCommand|
%   but with several differences.  First, the command simply creates
%   the requested command without regard to its existence.  Secondly,
%   the \marg{Code} supplied is fully expanded without protection.
%   Lastly, the definitions are global.
%
%   \begin{Usage}
%       \item |\MakeExpandedCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeExpandedCommand { m +m }
    {\cs_get:cpx {#1} {#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeCommandUndefined}
%   Globally undefines the command specified by \marg{Command Name}.
%
%   \begin{Usage}
%       \item |\MakeCommandUndefined|\marg{Command Name}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeCommandUndefined { m }
    {\cs_undefine:c {#1}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\CopyCommand}
%   Copies the defintion of the command named \marg{Command Name 1} to 
%   a new command named \marg{Command Name 2}.  If \marg{Command Name 2}
%   already has a definition, |\CopyCommand| will throw a warning
%   \emph{but} still make the copy.
%
%   \begin{Usage}
%       \item |\CopyCommand|\marg{Command Name 1}\marg{Command Name 2}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \CopyCommand { m m }
    {\IfCommandExists{#1}
        {\IfCommandExists{#2}
            {\UWMad@ClassWarning{Command~`#2'~is~defined.}}
            {}
            \cs_gset_eq:cc {#2}{#1}}
        {\UWMad@ClassWarning{Command~`#1'~is~undefined.}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%   \begin{macro}{\__UWMad_IsLocal:nnnnn}
%   Certain subsystems of the Programming Module make a distinction
%   between local and global variables where scope is determined by
%   \TeX{} groups.  This command takes five arguments designed to 
%   increased maintainability and readability in the subsystems that
%   use it.
%
%   This command accepts a \marg{Prefix}, an \marg{ID}, a \marg{Type},
%   \marg{LocalCode}, and \marg{GLobalCode}.  All subsystems that use
%   this command have (in theory) already defined a command of the form
%   \cmd{\marg{Prefix}\marg{ID}_Local} or \cmd{\marg{Prefix}\marg{ID}_Global}
%   of a specific \marg{Type}.  If either of the commands is defined, the
%   appropriate code is executed (in an fully expandable fashion, which is
%   used to reduce code duplication where possible).  If neither of those
%   commands exist, the variable is not registered with the system and an
%   exception is thrown.
%
%   As an example, the command |\DefineNewGlobalCounter{Example}| will create
%   a counter \marg{Type} variable |\g__UWMad_Counter_Example_Global| where
%   |g__UWMad_Counter_| is the \marg{Prefix}, |Example| is the \marg{ID}, and
%   |_Global| is the scope indicator leveraged by
%   |\__UWMad_IsLocal:nnnnn| for branching.
%
%   \begin{Usage}
%       \item |\UWMad_IsLocal:nnnnn| \marg{Prefix}\marg{ID}\marg{Type}
%                               \marg{LocalCode}, and \marg{GLobalCode}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_IsLocal:nnnnn{
    \cs_if_exist:cTF     {#1#2_Local}{
        #4
    }{
        \cs_if_exist:cTF {#1#2_Global}{
            #5
        }{
            \UWMad@ClassWarning{`#2'~is~not~a~registered~#3.}
        }
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\__UWMad_IsLocal_Counter:nnn}
%   \begin{macro}{\__UWMad_IsLocal_Length:nnn}
%   \begin{macro}{\__UWMad_IsLocal_Boolean:nnn}
%   Shortcuts for |\__UWMad_IsLocal:nnnnn| for the various
%   subsystems.  These commands only take an \marg{ID},
%   \marg{LocalCode}, and \marg{GlobalCode}.
%
%   \begin{Usage}
%       \item |\__UWMad_IsLocal_Counter:nnn|\marg{ID}
%                               \marg{LocalCode}\marg{GLobalCode}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \__UWMad_IsLocal_Counter:nTF {
    \__UWMad_IsLocal:nnnnn
        {g__UWMad_Counter_}{#1}{counter}{#2}{#3}
}
\cs_new:Nn \__UWMad_IsLocal_Length:nTF {
    \__UWMad_IsLocal:nnnnn
        {g__UWMad_Length_}{#1}{length}{#2}{#3}
}
\cs_new:Nn \__UWMad_IsLocal_Boolean:nTF {
    \__UWMad_IsLocal:nnnnn
        {g__UWMad_Boolean_}{#1}{boolean}{#2}{#3}
}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%   \end{macro}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Boolean System                            %
%^^A ==================================================================== %
%
%   \subsection{Boolean System}
%   This subsystem was made to give a \LaTeX{}-like branching system that
%   can create both local and global switches.
%
%   The system is a thin abstraction of
%   \LaTeXPL's |bool| module in the |l3prg| package to avoid developing
%   a one-shot system while allowing more endeavouring authors access to
%   to the simple feature without learning \LaTeX3{} programming.
%
\DeclareDocumentCommand \DefineLocalIf { m } {
    \bool_new:c {g__UWMad_Boolean_#1_Local}
}
\DeclareDocumentCommand \DefineGlobalIf { m } {
    \bool_new:c {g__UWMad_Boolean_#1_Global}
    }
%
%
\DeclareDocumentCommand \DefineLocalIfSetTrue { m } {
    \bool_new:c       {g__UWMad_Boolean_#1_Local}
    \bool_gset_true:c {g__UWMad_Boolean_#1_Local}
}
\DeclareDocumentCommand \DefineLocalIfSetFalse { m } {
    \bool_new:c       {g__UWMad_Boolean_#1_Local}
    \bool_gset_true:c {g__UWMad_Boolean_#1_Local}
}
%
\DeclareDocumentCommand \DefineGlobalIfSetTrue { m } {
    \bool_new:c       {g__UWMad_Boolean_#1_Global}
    \bool_gset_true:c {g__UWMad_Boolean_#1_Global}
}
\DeclareDocumentCommand \DefineGlobalIfSetFalse { m } {
    \bool_new:c       {g__UWMad_Boolean_#1_Global}
     \bool_gset_true:c {g__UWMad_Boolean_#1_Global}
}
%
%
\DeclareDocumentCommand \SetTrue { m } {
    \__UWMad_IsLocal_Boolean:nTF {#1} {
        \bool_set_true:c  {g__UWMad_Boolean_#1_Local}
    }{
        \bool_gset_true:c {g__UWMad_Boolean_#1_Global}
    }
}
\DeclareDocumentCommand \SetFalse { m } {
    \__UWMad_IsLocal_Boolean:nTF {#1} {
        \bool_set_false:c  {g__UWMad_Boolean_#1_Local}
    }{
        \bool_gset_false:c {g__UWMad_Boolean_#1_Global}
    }
}
%
%
\DeclareDocumentCommand \IfTrue { m +m +m}{
    \__UWMad_IsLocal_Boolean:nTF {#1} {
        \bool_if:cTF {g__UWMad_Boolean_#1_Local}
    }{
        \bool_if:cTF {g__UWMad_Boolean_#1_Global}
    }
    {#2}
    {#3}
}
\DeclareDocumentCommand \IfFalse { m +m +m}{
    \__UWMad_IsLocal_Boolean:nTF {#1} {
        \bool_if:cTF {g__UWMad_Boolean_#1_Local}
    }{
        \bool_if:cTF {g__UWMad_Boolean_#1_Global}
    }
    {#3}
    {#2}
}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Length System                             %
%^^A ==================================================================== %
%
%   \subsection{Length System}
%   This subsystem was made to give a \LaTeX{}-like length system that
%   can create both local and global lengths.
%
%   The system is a thin abstraction of
%   \LaTeXPL's |dim| module in the |l3skip| package to avoid developing
%   a one-shot system while allowing more endeavouring authors access to
%   to the simple feature without learning \LaTeX3{} programming.
%
\DeclareDocumentCommand \DefineLocalLength  { m m } {
    \dim_new:c   {g__UWMad_Length_#1_Local}
    \dim_gset:cn {g__UWMad_Length_#1_Local} {#2}
}
\DeclareDocumentCommand \DefineGlobalLength { m m } {
    \dim_new:c   {g__UWMad_Length_#1_Global}
    \dim_gset:cn {g__UWMad_Length_#1_Global} {#2}
}
%
%
\DeclareDocumentCommand \AddToLength { m m } {
    \__UWMad_IsLocal_Length:nTF {#1} {
        \dim_add:cn  {g__UWMad_Length_#1_Local}  {#2}
    }{
        \dim_gadd:cn {g__UWMad_Length_#1_Global} {#2}
    }
}
%
\DeclareDocumentCommand \SetLength { m m }{
    \__UWMad_IsLocal_Length:nTF {#1} {
        \dim_set:cn  {g__UWMad_Length_#1_Local}  {#2}
    }{
        \dim_gset:cn {g__UWMad_Length_#1_Global} {#2}
    }
}
%
\DeclareDocumentCommand \LengthOf { m } {
    \__UWMad_IsLocal_Length:nTF {#1} {
        \dim_use:c {g__UWMad_Length_#1_Local}
    }{
        \dim_use:c {g__UWMad_Length_#1_Global}
    }
}
%
\DeclareDocumentCommand \IfLength{ m m m +m +m }{
    \dim_compare:nTF{ \LengthOf{#1} #2 #3 }{
        #4
    }{
        #5
    }
}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Counter System                            %
%^^A ==================================================================== %
%
%   \subsection{Counter System}
%   This subsystem was made to give a \LaTeX{}-like counter system that
%   can create both local and global counters.
%
%
%   \begin{macro}{\DefineNewLocalCounter}
%   \begin{macro}{\DefineNewGlobalCounter}
%   This pair creates either a local or global counter named
%   \marg{Counter Name} with \marg{Initial Value}. The counters
%   are registered, defined to be local or global, initialized
%   by |\newcount|, and set to \marg{Initial Value}.
%
%   \begin{Usage}
%       \item |\DefineNewLocalCounter|\marg{Counter Name}{Initial Value}
%       \item |\DefineNewGlobalCounter|\marg{Counter Name}{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DefineNewLocalCounter { m m } {
    \int_new:c   {g__UWMad_Counter_#1_Local}
    \int_gset:cn {g__UWMad_Counter_#1_Local} {#2}
}
\DeclareDocumentCommand \DefineNewGlobalCounter { m m } {
    \int_new:c   {g__UWMad_Counter_#1_Global}
    \int_gset:cn {g__UWMad_Counter_#1_Global} {#2}
}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\AddToCounter}
%   This command adds \marg{Increment} to the current value of counter
%   \marg{CounterName}. |\UWMad_IsLocal:nnn| handles the local vs.
%   global advancement.
%
%   \begin{Usage}
%       \item |\AddToCounter|\marg{CounterName}\marg{Increment}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \AddToCounter { m m } {
    \__UWMad_IsLocal_Counter:nTF {#1} {
        \int_add:cn  {g__UWMad_Counter_#1_Local}  {#2}
    }{
        \int_gadd:cn {g__UWMad_Counter_#1_Global} {#2}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\StepCounter}
%   Adds $1$ to the counter \marg{Counter Name}.
%   |\UWMad_IsLocal:nnn| handles the local vs. global advancement.
%
%   \begin{Usage}
%       \item |\StepCounter|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \StepCounter { m }{
    \AddToCounter{#1}{1}
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\SetCounter}
%   This command sets the value of counter \marg{Counter Name} to \marg{Value}.
%   |\UWMad_IsLocal:nnn| handles the local vs. global assignment.
%
%   \begin{Usage}
%       \item |\SetCounter|\marg{Counter Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \SetCounter { m m }{
    \__UWMad_IsLocal_Counter:nTF {#1} {
        \int_set:cn  {g__UWMad_Counter_#1_Local}  {#2}
    }{
        \int_gset:cn {g__UWMad_Counter_#1_Global} {#2}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\SetAndAddToCounter}
%   \begin{macro}{\SetAndStepCounter}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%
%   \begin{Usage}
%       \item |\SetAndAddToCounter|\marg{Counter Name}\marg{Initial Value}\marg{Value}
%       \item |\SetAndStepCounter|\marg{Counter Name}\marg{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \SetAndAddToCounter { m m m }{
    \SetCounter{#1}{#2}
    \AddToCounter{#1}{#3}
}
\DeclareDocumentCommand \SetAndStepCounter { m m }{
    \SetAndAddToCounter{#1}{#2}{1}
}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\CounterValue}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%
%   \begin{Usage}
%       \item |\CounterValue|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \CounterValue { m }{
    \__UWMad_IsLocal_Counter:nTF {#1} {
        \int_use:c {g__UWMad_Counter_#1_Local}
    }{
        \int_use:c {g__UWMad_Counter_#1_Global}
    }
}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ======================================================================= %
%^^A                          CSV Creation Commands                          %
%^^A ======================================================================= %
%
%   \subsection{CSV System}
%   This set of commands is a simple system for comma-separated value (CSV)
%   list creation.  It consists of only a few functions: initialize list,
%   append value, prepend value, get list, and erase list.
%
%   This feature was created solely to export |hyperref| meta-data to an
%   external file for later reading.  The system is a thin abstraction of
%   \LaTeXPL's |l3clist| package to avoid developing
%   a one-shot system while allowing more endeavouring authors access to
%   to the simple feature without learning \LaTeX3{} programming.
%
\DeclareDocumentCommand  \CSVMake { m } {
    \clist_new:c {g__UWMad_CSV_#1}
}

\DeclareDocumentCommand \CSVClear { m } {
    \clist_gclear:c {g__UWMad_CSV_#1}
}

\DeclareDocumentCommand \CSVAppend { m m } {
    \clist_if_exist:cTF {g__UWMad_CSV_#1}{}{
        \clist_new:c {g__UWMad_CSV_#1}
    }
    \clist_gput_right:cn {g__UWMad_CSV_#1} {#2}
}
%
\DeclareDocumentCommand \CSVPrepend { m m } {
    \clist_if_exist:cTF {g__UWMad_CSV_#1}{}{
        \clist_new:c {g__UWMad_CSV_#1}
    }
    \clist_gput_left:cn {g__UWMad_CSV_#1} {#2}
}
%
\DeclareExpandableDocumentCommand \CSVGet { m } {
    \use:c {g__UWMad_CSV_#1}
}
%
\DeclareDocumentCommand  \IfCSVExists { m m m } {
    \clist_if_exist:cTF {g__UWMad_CSV_#1}{
        #2
    }{
        #3
    }
}
%
%
%
%
%
%
%^^A ======================================================================= %
%^^A                     Collection Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsection{Collections}
%   In the following subsections, commands that create and manipulate
%   various collection data types will be discussed.  The collections
%   currently implemented are stacks (LIFO), queues (FIFO), and deques
%   (LIFO+FIFO).
%
%   All of the collection systems are thin abstractions of \LaTeXPL's
%   |l3seq| module to avoid developing one-shot systems while allowing more
%   endeavoring authors access to the features without learning \LaTeX3{}
%   programming.
%
%
%
%^^A ======================================================================= %
%^^A                          Stack Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsubsection{Stack System}
%   This set of commands is a simple system for creating and working with
%   stacks.  Stacks are a last-in first-out collection data type; this means
%   that the data element (in this any unexpanded token/token list) last 
%   pushed on to the stack is the first popped.  Data elements can also be
%   walked (iterated over) with an inline callback in a LIFO sense.
%
%
%
\DeclareDocumentCommand \StackMake { m }
    {\tl_new:c {g__UWMad_Stack_#1}}
%
%
\DeclareDocumentCommand \StackDelete { m }
    {\tl_if_exist:cTF   {g__UWMad_Stack_#1}
        {\tl_gclear:c   {g__UWMad_Stack_#1}
         \cs_undefine:c {g__UWMad_Stack_#1}}
        {}}
%
%
\DeclareDocumentCommand \StackPush { m +m }
    {\tl_if_exist:cTF     {g__UWMad_Stack_#1}
        {\tl_gput_left:cn {g__UWMad_Stack_#1} {#2}}
        {}}
%
%
\cs_generate_variant:Nn \tl_head:N { c }
\cs_generate_variant:Nn \tl_tail:N { c }
%
\DeclareDocumentCommand \StackPop { m }
    {\tl_set:Nx \l_tmpa_tl          {\tl_head:c {g__UWMad_Stack_#1}}
     \tl_set:cx {g__UWMad_Stack_#1} {\tl_tail:c {g__UWMad_Stack_#1}}
     \tl_use:N \l_tmpa_tl}
%
%
\DeclareDocumentCommand \StackWalk { m +m }
    {\tl_map_inline:cn {g__UWMad_Stack_#1} {#2}}
%
%
%
%^^A ======================================================================= %
%^^A                          Queue Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsubsection{Queue System}
%   This set of commands is a simple system for creating and working with
%   queue.  Queues are a first-in first-out collection data type; this means
%   that the data element (in this any unexpanded token/token list) first 
%   pushed on to the queue is the first popped.  Data elements can also be
%   walked (iterated over) with an inline callback in a FIFO sense.
%
%
%
\DeclareDocumentCommand \QueueMake { m }
    {\tl_new:c {g__UWMad_Queue_#1}}
%
%
\DeclareDocumentCommand \QueueDelete { m }
    {\tl_if_exist:cTF   {g__UWMad_Queue_#1}
        {\tl_gclear:c   {g__UWMad_Queue_#1}
         \cs_undefine:c {g__UWMad_Queue_#1}}
        {}}
%
%
\DeclareDocumentCommand \QueueClear { m }
    {\tl_if_exist:cTF   {g__UWMad_Queue_#1}
        {\tl_gclear:c   {g__UWMad_Queue_#1}}
        {}}
%
%
\DeclareDocumentCommand \QueuePush { m +m }
    {\tl_if_exist:cTF     {g__UWMad_Queue_#1}
        {\tl_gput_left:cn {g__UWMad_Queue_#1} {{#2}}}
        {}}
%
%
\cs_generate_variant:Nn \tl_head:N { c }
\cs_generate_variant:Nn \tl_tail:N { c }
%
\DeclareDocumentCommand \QueuePop { m }
    {\tl_reverse:c   {g__UWMad_Queue_#1}
     \tl_set:Nx \l_tmpa_tl
        {\tl_head:c  {g__UWMad_Queue_#1}}
     \tl_set:cx      {g__UWMad_Queue_#1}
        {\tl_tail:c  {g__UWMad_Queue_#1}}
     \tl_reverse:c   {g__UWMad_Queue_#1}
     \tl_use:N \l_tmpa_tl}
%
%
\DeclareDocumentCommand \QueueWalk { m +m }
    {\group_begin:
        \tl_reverse:c     {g__UWMad_Queue_#1}
        \tl_map_inline:cn {g__UWMad_Queue_#1} {#2}
     \group_end:}
%
%
\DeclareDocumentCommand \IfQueueEmpty { m +m +m }
    {\tl_if_empty:cTF {g__UWMad_Queue_#1}
        {#2}
        {#3}}
%
%
%
%^^A ======================================================================= %
%^^A                          Deque Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsubsection{Deque System}
%   This set of commands is a simple system for creating and working with
%   double-ended queues (deques, pronounced \textit{deck}).  Deques are a
%   generalization of stacks and queues in that data can be pushed, popped,
%   and walked from either end of the list (i.e., LIFO+FIFO).
%
%
\DeclareDocumentCommand \DequeMake { m }
    {\seq_new:c {g_UWMad_Deque_#1}}
%
%
\DeclareDocumentCommand \DequeDelete { m }
    {\seq_if_exist:cTF  {g_UWMad_Deque_#1}
        {\seq_gclear:c  {g_UWMad_Deque_#1}
         \cs_undefine:c {g_UWMad_Deque_#1}}
        {}}
%
%
\DeclareDocumentCommand \DequePushLeft  { m +m }
    {\seq_gput_left:cn  {g_UWMad_Deque_#1} {#2}}
\DeclareDocumentCommand \DequePushRight { m +m }
    {\seq_gput_right:cn {g_UWMad_Deque_#1} {#2}}
%
%
\DeclareDocumentCommand \DequePopLeft { m }
    {\seq_gpop_left:cN  {g_UWMad_Deque_#1} \l_tmpa_tl
     \tl_use:N \l_tmpa_tl}
\DeclareDocumentCommand \DequePopRight { m }
    {\seq_gpop_right:cN {g_UWMad_Deque_#1} \l_tmpa_tl
     \tl_use:N \l_tmpa_tl}
%
%
\DeclareDocumentCommand \DequeWalkLeftToRight { m +m }
    {\seq_if_exist:cTF {g_UWMad_Deque_#1}
        {\seq_map_inline:cn {g_UWMad_Deque_#1} {#2}}
        {}}
%
%
\cs_generate_variant:Nn \seq_reverse:N {c}
\DeclareDocumentCommand \DequeWalkRightToLeft { m +m }
    {\group_begin:
        \seq_if_exist:cTF       {g_UWMad_Deque_#1}
            {\seq_reverse:c     {g_UWMad_Deque_#1}
             \seq_map_inline:cn {g_UWMad_Deque_#1} {#2}}
            {}
     \group_end:}
%
%
%
%
%
%
% =========================================================================== %
%                 Hashes (Associative Arrays) with LaTeX3                     %
% =========================================================================== %
%
%   \subsubsection{Hash System}
%   This set of commands is a simple system for creating and working with
%   hashes (more often called associative arrays or dictionaries, but erring
%   on the side of usablility, Ruby's verbarge will be used). Hashes are a
%   type of array that indexes values by (at least in \LaTeX{}) alphanumeric
%   keys instead of just integers.
%   Data can BE set by key, retrieved by key, unset by key, deleted, and walked.
%
%   A hash walk, like the collection walks above, iterates through all of the
%   keys and values in the hash while applying a user supplied function.
%   However, unlike the collection walks, \textbf{a hash's walk order is not
%   gauranteed to be the set order}.  If walk order is needed to be
%   gauranteed, see the previous collection data types.
%
%   The system is a thin abstraction of \LaTeXPL's
%   |l3prop| module to avoid developing a one-shot system while allowing more
%   endeavoring authors access to the feature without learning \LaTeX3{}
%   programming.
%
%
\cs_generate_variant:Nn \prop_gput:Nnn   { c x n   }
\cs_generate_variant:Nn \prop_if_in:NnTF { c x TF  }
\cs_generate_variant:Nn \prop_if_in:NnTF { c f TF  }
\cs_generate_variant:Nn \prop_get:Nn     { c x     }
\cs_generate_variant:Nn \prop_get:Nn     { c f     }
\cs_generate_variant:Nn \prop_get:NnNTF  { c x N TF}
\cs_generate_variant:Nn \prop_gremove:Nn { c x     }

\DeclareDocumentCommand \HashMake { m }
    {\prop_new:c {g_UWMad_Hash_#1}}

\DeclareDocumentCommand \HashSet { m m +m }
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}
        {\prop_gput:cxn {g_UWMad_Hash_#1}{#2}{#3}}
        {\HashMake{#1}
         \prop_gput:cxn {g_UWMad_Hash_#1}{#2}{#3}}}

\DeclareDocumentCommand \HashGet { m m }
    {\prop_get:cxNTF {g_UWMad_Hash_#1} {#2} \l_tmpa_prop
        {\tl_use:N \l_tmpa_prop}
        {}}

\DeclareExpandableDocumentCommand \HashExpandableGet { m m }
    {\prop_if_in:cfTF {g_UWMad_Hash_#1} {#2}
        {\prop_get:cf {g_UWMad_Hash_#1} {#2}}
        {}}

\DeclareDocumentCommand \HashUnset { m m }
    {\prop_if_exist:cTF   {g_UWMad_Hash_#1}
        {\prop_gremove:cx {g_UWMad_Hash_#1} {#2}}
        {}}

\cs_generate_variant:Nn \tl_to_lowercase:n {f}

\DeclareDocumentCommand \IfHashKeySet { m m +m +m } {
    \prop_if_exist:cTF   {g_UWMad_Hash_#1}{
        \prop_if_in:cfTF {g_UWMad_Hash_#1} {\tl_trim_spaces:n{#2}}
            {#3}
            {#4}
    }{
    }
}

\DeclareDocumentCommand \HashWalk {m +m}
    {\prop_if_exist:cTF      {g_UWMad_Hash_#1}
        {\prop_map_inline:cn {g_UWMad_Hash_#1}
            {#2}}
        {}}

\DeclareDocumentCommand \HashDelete { m }
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}
        {\prop_gclear:c {g_UWMad_Hash_#1}
         \cs_undefine:c {g_UWMad_Hash_#1}}
        {}}
%
%
%
\ExplSyntaxOff
%</Module:Programming>
%Verbatim
%</Implementation>