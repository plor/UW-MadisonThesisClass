%<*UserGuide>
\ifUWMad@UserGuide

\subsection{Programming}\label{UG:Programming}
The Programming Module has no immediate user-facing features.
The Implementation section for this module outlines the programming layer
and is aimed mainly at authors that wish to utilize its abilities.

\fi
%</UserGuide>
%
%
%
%<*Implementation>
%<<Verbatim
%<*Module:Programming>
%
%^^A
%^^A  Module Name: Programming
%^^A  Author:
%^^A    Name:           Troy C. Haskin
%^^A    E-mail:         UWMadThesis@hask.in
%^^A  Version:
%^^A    Number:         1.0
%^^A    Description:    Initial release
%^^A    Date:           06/01/2013
%^^A  Purpose:
%^^A    Provide a programming layer for the UW-Madison Thesis package
%^^A    Most of the module is designed to overcome the lack of such a
%^^A    layer in LaTeX2e.  Some LaTeX3 is being used for certain advanced
%^^A    features, and this module may become obsolete when/if it is upgraded
%^^A    to a pure LaTeX3 implementation; though a thin abatraction layer may
%^^A    still be desired.
%
%   \subsection{Programming Module}\label{Imp:Programming}
%   This section outlines the Programming module for the \UWMadClass.
%   It is mostly a collection of utility macros used in other modules.
%   The two biggest features in this module are the Array and Hash 
%   (associative arrays) systems used a other modules.  Those features 
%   are near the end of this subsection.
%
%   The commands are currently a mix of \TeX{}, \LaTeX2e{}, and \LaTeX3{}.
%   Pure \TeX{} is used only where the other features have no such facility
%   for the intended purpose.  Also, the |etoolbox| package is used as
%   the basis for many of the utility macros, and those macros are actually,
%   for all intents and purposes, just aliases for etoolbox commands. This
%   method was chosen to allow for an easier transition to another system.
%
%
%^^A ==================================================================== %
%^^A                            Utility Macros                            %
%^^A ==================================================================== %
%
%   \subsubsection{Utility Macros}
%
%   \begin{macro}{\GlobalNewIf}
%   Changes to if-switches only have block level scope by default.
%   Therefore, switches generated by |\newif| revert to their pre-block
%   state upon exiting a scope regardless of any non-global changes within
%   the block.  This command creates an if-switch pair that has inherent
%   global scope.
%
%   \begin{Usage}
%       \item |\GlobalNewIf|\marg{SwitchName}
%   \end{Usage}
%
%    \begin{macrocode}
\ExplSyntaxOn
\DeclareDocumentCommand \GlobalNewIf { m }
    {\cs_gset_nopar:cpn {#1true}
        {\cs_gset_eq:cc {if#1} {iftrue}}
     \cs_gset_nopar:cpn {#1false}
        {\cs_gset_eq:cc {if#1} {iffalse}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfCommandExists}
%   \begin{macro}{\IfCommandDoesNotExist}
%   This command pair is used instead of \LaTeX{}'s |\@ifundefined|.
%   Since it is \eTeX{}, this command will allow for a switch to
%   |\@ifundefined| if problems arise from non-\eTeX{} users in the
%   future.
%
%   \begin{Usage}
%       \item |\IfCommandExists|\marg{Command Name}\marg{True}\marg{False}
%       \item |\IfCommandDoesNotExist|\marg{Command Name}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfCommandExists { m +m +m }
    {\cs_if_exist:cTF {#1}
        {#2}
        {#3}}
\DeclareDocumentCommand \IfCommandDoesNotExist { m +m +m }
    {\cs_if_free:cTF {#1}
        {#2}
        {#3}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfGreaterThanEqualTo}
%   \begin{macro}{\IfLessThanEqualTo}
%   This set of commands uses \TeX{} primitives to allow conditional code
%   execution of the variety: \marg{Oper1} $\geq$ \marg{Oper2} and 
%                             \marg{Oper1} $\leq$ \marg{Oper2}.
%
%   \begin{Usage}
%       \item |\IfGreaterThanEqualTo|\marg{Oper1}\marg{Oper2}\marg{True}\marg{False}
%       \item |\IfLessThanEqualTo|\marg{Oper1}\marg{Oper2}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfGreaterThanEqualTo { m m m m }
    {\ifnum#1>#2
        #3
     \else
        \ifnum#1=#2
            #3
        \else
            #4
        \fi
     \fi}
\DeclareDocumentCommand \IfLessThanEqualTo { m m m m }
    {\ifnum#1<#2
        #3
     \else
        \ifnum#1=#2
            #3
        \else
            #4
        \fi
     \fi}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfStringEmpty}
%   Checks if a given string is empty.
%   It uses the |etoolbox|'s |\ifblank|.
%   This command will not expand input.
%
%   \begin{Usage}
%       \item |\IfStringEmpty|\marg{String}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfStringEmpty { m +m +m }
    {\tl_if_blank:nTF {#1}
        {#2}
        {#3}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfCommandEmpty}
%   Uses the |etoolbox|'s |\ifdefempty| command to test if a command expands
%   to an empty string and is followed by the given conditional code.
%
%   \begin{Usage}
%       \item |IfCommandEmpty|\marg{Command}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \IfCommandEmpty { m +m +m }
    {\tl_if_blank:oTF{#1}
        {#2}
        {#3}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewLength}
%   This is a convenience command used to define a new length
%   \marg{Length Name} and set its \marg{Value}.
%
%   \begin{Usage}
%       \item |DefineNewLength|\marg{Length Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\DefineNewLength}[2]
    {\newlength{#1}%
     \setlength{#1}{#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewCounter}
%   This is a convenience command used to define a new \LaTeX{} counter
%   \marg{Counter Name} and set its \marg{Value}.
%
%   \begin{Usage}
%       \item |DefineNewCounter|\marg{Counter Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\DefineNewCounter}[2]
    {\newcounter{#1}%
     \setcounter{#1}{#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                      Command Creator System                          %
%^^A ==================================================================== %
%
%   \subsubsection{Command Creator System}
%
%   \begin{macro}{\MakeCommand}
%   \begin{macro}{\ReMakeCommand}
%   This command pair uses the |etoolbox|'s |\csdef| to define a commands
%   via a supplied string \marg{Command Name} and a set of \marg{Code}.
%   If the requested command is not defined, |\MakeCommand| will create it;
%   however, if the requested command is already defined, |\MakeCommand| will
%   throw a warning and not make the command.
%   If the requested command is defined, |\ReMakeCommand| will redefine it;
%   however, if the requested command is not defined, |\ReMakeCommand| will
%   throw a warning and not make the command.
%
%   \begin{Usage}
%       \item |\MakeCommand|\marg{Command Name}\marg{Code}
%       \item |\ReMakeCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeCommand { m +m }
    {\cs_set:cpn {#1} {#2}}
\DeclareDocumentCommand \ReMakeCommand { m +m }
    {\IfCommandExists{#1}
        {\cs_set:cpn {#1} {#2}}
        {\UWMad@ClassWarning{Command\ `#1'\ is undefined.}}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeGlobalCommand}
%   Similar to |\MakeCommand| except the creation is made regardless of the
%   requested command's definition and the creation is global.
%
%   \begin{Usage}
%       \item |\MakeGlobalCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeGlobalCommand { m +m }
    {\cs_gset:cpn {#1} {#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeExpandedCommand}
%   This command creates a command in the spirit of |\MakeCommand|
%   but with several differences.  First, the command simply creates
%   the requested command without regard to its existence.  Secondly,
%   the \marg{Code} supplied is fully expanded without protection.
%   Lastly, the definitions are global.
%
%   \begin{Usage}
%       \item |\MakeExpandedCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeExpandedCommand { m +m }
    {\cs_get:cpx {#1} {#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeCommandUndefined}
%   Globally undefines the command specified by \marg{Command Name}.
%
%   \begin{Usage}
%       \item |\MakeCommandUndefined|\marg{Command Name}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \MakeCommandUndefined { m }
    {\cs_undefined:c {#1}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\CopyCommand}
%   Copies the defintion of the command named \marg{Command Name 1} to 
%   a new command named \marg{Command Name 2}.  If \marg{Command Name 2}
%   already has a definition, |\CopyCommand| will throw a warning
%   \emph{but} still make the copy.
%
%   \begin{Usage}
%       \item |\CopyCommand|\marg{Command Name 1}\marg{Command Name 2}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \CopyCommand { m m }
    {\IfCommandExists{#1}
        {\IfCommandExists{#2}
            {\UWMad@ClassWarning{Command\ `#2'\ is defined.}}
            {}
            \cs_gset_eq:cc {#2}{#1}}
        {\UWMad@ClassWarning{Command\ `#1'\ is undefined.}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Counter System                            %
%^^A ==================================================================== %
%
%   \subsubsection{Counter System}
%   This subsystem was made to give a \LaTeX{}-like counter system that
%   can create both local and global counters.
%
%   \begin{macro}{\g_UWMad_RegisteredCounter}
%   \begin{macro}{\g_UWMad_LocalCounter}
%   \begin{macro}{\g_UWMad_GlobalCounter}
%   These commands define the command name suffixes used to store, identify,
%   and protect (from the user) the counter commands.  All counters created
%   by the system are given a registration command to indicate it is part of
%   the system and either a local or global command to indicate if a global
%   assignment or advancement is needed.  The counter itself is created 
%   without any prefix or suffix for usage by the user.
%
%    \begin{macrocode}
\tl_const:Nn \g_UWMad_RegisteredCounter {UWMad_RegisteredCounter}
\tl_const:Nn \g_UWMad_LocalCounter      {UWMad_LocalCounter}
\tl_const:Nn \g_UWMad_GlobalCounter     {UWMad_GlobalCounter}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewLocalCounter}
%   \begin{macro}{\DefineNewGlobalCounter}
%   This pair creates either a local or global counter named
%   \marg{Counter Name} with \marg{Initial Value}. The counters
%   are registered, defined to be local or global, initialized
%   by |\newcount|, and set to \marg{Initial Value}.
%
%   \begin{Usage}
%       \item |\DefineNewLocalCounter|\marg{Counter Name}{Initial Value}
%       \item |\DefineNewGlobalCounter|\marg{Counter Name}{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DefineNewLocalCounter { m m }
    {\tl_const:cn {#1 \tl_use:N \g_UWMad_RegisteredCounter} {}
     \tl_const:cn {#1 \tl_use:N \g_UWMad_LocalCounter}      {}
     \int_new:c {#1}
     \int_gset:cn {#1} {#2}}
\DeclareDocumentCommand \DefineNewGlobalCounter { m m }
    {\tl_const:cn {#1 \tl_use:N \g_UWMad_RegisteredCounter} {}
     \tl_const:cn {#1 \tl_use:N \g_UWMad_GlobalCounter}     {}
     \int_new:c {#1}
     \int_gset:cn {#1} {#2}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\UWMad_LocalOrGlobal:nnn}
%   This command expands to either \marg{LocalCode} \marg{GLobalCode}
%   depending on the definition of the counter \marg{CounterName}.
%   If the counter is not registered with the system, a warning is thrown.
%
%   \begin{Usage}
%       \item |\UWMad_LocalOrGlobal:nnn|\marg{CounterName}\marg{LocalCode}\marg{GlobalCode}
%   \end{Usage}
%
%    \begin{macrocode}
\cs_new:Nn \UWMad_LocalOrGlobal:nnn
    {\tl_if_exist:cTF{#1 \tl_use:N \g_UWMad_RegisteredCounter}
        {\tl_if_exist:cTF{#1 \tl_use:N \g_UWMad_LocalCounter}
            {#2}
            {#3}}
        {\UWMad@ClassWarning{`#1'\ is not a registered counter.}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\AddToCounter}
%   This command adds \marg{Increment} to the current value of counter
%   \marg{CounterName}. |\UWMad_LocalOrGlobal:nnn| handles the local vs.
%   global advancement.
%
%   \begin{Usage}
%       \item |\AddToCounter|\marg{CounterName}\marg{Increment}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \AddToCounter { m m }
    {\UWMad_LocalOrGlobal:nnn {#1}
        {\int_add:cn  {#1} {#2}}
        {\int_gadd:cn {#1} {#2}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\StepCounter}
%   Adds $1$ to the counter \marg{Counter Name}.
%   |\UWMad_LocalOrGlobal:nnn| handles the local vs. global advancement.
%
%   \begin{Usage}
%       \item |\StepCounter|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \StepCounter { m }
    {\AddToCounter{#1}{1}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\SetCounter}
%   This command sets the value of counter \marg{Counter Name} to \marg{Value}.
%   |\UWMad_LocalOrGlobal:nnn| handles the local vs. global assignment.
%
%   \begin{Usage}
%       \item |\SetCounter|\marg{Counter Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \SetCounter { m m }
    {\UWMad_LocalOrGlobal:nnn {#1}
        {\int_set:cn  {#1} {#2}}
        {\int_gset:cn {#1} {#2}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\SetAndAddToCounter}
%   \begin{macro}{\SetAndStepCounter}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%   |\UWMad_LocalOrGlobal:nnn| handles the local vs. global assignment.
%
%   \begin{Usage}
%       \item |\SetAndAddToCounter|\marg{Counter Name}\marg{Initial Value}\marg{Value}
%       \item |\SetAndStepCounter|\marg{Counter Name}\marg{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \SetAndAddToCounter { m m m }
    {\SetCounter{#1}{#2}
     \AddToCounter{#1}{#3}}
\DeclareDocumentCommand \SetAndStepCounter { m m }
    {\SetAndAddToCounter{#1}{#2}{1}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\CounterValue}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%
%   \begin{Usage}
%       \item |\CounterValue|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\DeclareDocumentCommand \CounterValue { m }
    {\int_use:c {#1}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ======================================================================= %
%^^A                          CSV Creation Commands                          %
%^^A ======================================================================= %
%
%   \subsubsection{CSV System}
%   This set of commands is a simple system for comma-separated value (CSV)
%   list creation.  It consists of only a few functions: initialize list,
%   append value, prepend value, get list, and erase list.
%
%   This feature was created solely to export |hyperref| meta-data to an
%   external file for later reading.  The system is a thin abstraction of
%   \LaTeXPL's |l3clist| package to avoid developing
%   a one-shot system while allowing more endeavouring authors access to
%   to the simple feature without learning \LaTeX3{} programming.
%
\ExplSyntaxOn
\DeclareDocumentCommand  \CSVMake { m }
    {\clist_new:c {g_UWMad_CSV_#1}}

\DeclareDocumentCommand \CSVClear { m }
    {\clist_gclear:c {g_UWMad_CSV_#1}}

\DeclareDocumentCommand \CSVAppend { m m }
    {\clist_if_exist:cTF {g_UWMad_CSV_#1}
        {}
        {\clist_new:c {g_UWMad_CSV_#1}}
     \clist_gput_right:cn {g_UWMad_CSV_#1} {#2}}

\DeclareDocumentCommand \CSVPrepend { m m }
    {\clist_if_exist:cTF {g_UWMad_CSV_#1}
        {}
        {\clist_new:c {g_UWMad_CSV_#1}}
     \clist_gput_left:cn {g_UWMad_CSV_#1} {#2}}

\DeclareExpandableDocumentCommand \CSVGet { m }
    {\clist_use:c {g_UWMad_CSV_#1}}

\DeclareDocumentCommand  \IfCSVExists { m m m }
    {\clist_if_exist:cTF {g_UWMad_CSV_#1}
        {#2}
        {#3}}
%
%
%
%
%
%
%^^A ======================================================================= %
%^^A                          Deque Creation Commands                        %
%^^A ======================================================================= %
%
%   \subsubsection{Deque System}
%   This set of commands is a simple system for creating and working with
%   double-ended queues (deques, pronounced \textit{deck}).  Deques are a
%   generalization of stacks and queues in that data can be pushed, popped,
%   and walked from either end of the list.
%
%   The system is a thin abstraction of \LaTeXPL's
%   |l3seq| module to avoid developing a one-shot system while allowing more
%   endeavoring authors access to the feature without learning \LaTeX3{}
%   programming.
%
%
\DeclareDocumentCommand \DequeMake { m }
    {\seq_new:c {g_UWMad_Deque_#1}}
%
%
\DeclareDocumentCommand \DequeDelete { m }
    {\seq_if_exist:cTF {g_UWMad_Deque_#1}
        {\seq_gclear:c {g_UWMad_Deque_#1}
         \cs_undefine:c {g_UWMad_Deque_#1}}
        {}}
%
%
\DeclareDocumentCommand \DequePushLeft  { m +m }
    {\seq_gput_left:cn {g_UWMad_Deque_#1} {#2}}
\DeclareDocumentCommand \DequePushRight { m +m }
    {\seq_gput_right:cn {g_UWMad_Deque_#1} {#2}}
%
%
\DeclareDocumentCommand \DequePopLeft { m }
    {\seq_gpop_left:cN {g_UWMad_Deque_#1} \l_tmpa_tl
     \tl_use:N \l_tmpa_tl}
\DeclareDocumentCommand \DequePopRight { m }
    {\seq_gpop_right:cN {g_UWMad_Deque_#1} \l_tmpa_tl
     \tl_use:N \l_tmpa_tl}
%
%
\DeclareDocumentCommand \DequeWalkLeftToRight { m +m }
    {\seq_if_exist:cTF {g_UWMad_Deque_#1}
        {\seq_map_inline:cn {g_UWMad_Deque_#1} {#2}}
        {}}
%
%
\cs_generate_variant:Nn \seq_reverse:N {c}
\DeclareDocumentCommand \DequeWalkRightToLeft { m +m }
    {\group_begin:
        \seq_if_exist:cTF {g_UWMad_Deque_#1}
            {\seq_reverse:c {g_UWMad_Deque_#1}
             \seq_map_inline:cn {g_UWMad_Deque_#1} {#2}}
            {}
     \group_end:}
%
%
%
%
%
%
% =========================================================================== %
%                 Hashes (Associative Arrays) with LaTeX3                     %
% =========================================================================== %
%
%   \subsubsection{Hash System}
%   This set of commands is a simple system for creating and working with
%   hashes (more often called associative arrays, but since 
%   |\AssociativeArrayUnset| seemed error prone and annoying, the term 
%   Hash is used instead). Hashes are a type of array that indexes values
%   by (atleast in \LaTeX{}) alphanumeric keys instead of just integers.
%   Data can set by key, retrieved by key, unset by key, deleted, and walked.
%
%   A hash walk, like a deque walk, iterates through all of the keys and
%   values in the hash while applying a user supplied function.  However,
%   unlike a deque walk, \textbf{a hash's walk order is not gauranteed
%   to be the set order}.  If walk order is needed to be gauranteed,
%   see the previous Deque System.
%
%   The system is a thin abstraction of \LaTeXPL's
%   |l3prop| module to avoid developing a one-shot system while allowing more
%   endeavoring authors access to the feature without learning \LaTeX3{}
%   programming.
%
%
\cs_generate_variant:Nn \prop_gput:Nnn   { c x n   }
\cs_generate_variant:Nn \prop_if_in:NnTF { c x TF  }
\cs_generate_variant:Nn \prop_get:Nn     { c x     }
\cs_generate_variant:Nn \prop_get:NnNTF  { c x N TF}
\cs_generate_variant:Nn \prop_gremove:Nn { c x     }

\DeclareDocumentCommand \HashMake { m }
    {\prop_new:c {g_UWMad_Hash_#1}}

\DeclareDocumentCommand \HashSet { m m +m }
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}
        {\prop_gput:cxn {g_UWMad_Hash_#1}{#2}{#3}}
        {\HashMake{#1}
         \prop_gput:cxn {g_UWMad_Hash_#1}{#2}{#3}}}

\DeclareDocumentCommand \HashGet { m m }
    {\prop_get:cxNTF {g_UWMad_Hash_#1} {#2} \l_tmpa_prop
        {\tl_use:N \l_tmpa_prop}
        {}}

\DeclareExpandableDocumentCommand \HashExpandableGet { m m }
    {\prop_if_in:cxTF {g_UWMad_Hash_#1} {#2}
        {\prop_get:cx {g_UWMad_Hash_#1} {#2}}
        {}}

\DeclareDocumentCommand \HashUnset { m m }
    {\prop_if_exist:cTF   {g_UWMad_Hash_#1}
        {\prop_gremove:cx {g_UWMad_Hash_#1} {#2}}
        {}}

\DeclareDocumentCommand \IfHashKeySet { m m +m +m }
    {\prop_if_exist:cTF   {g_UWMad_Hash_#1}
        {\prop_if_in:cxTF {g_UWMad_Hash_#1} {#2}
            {#3}
            {#4}}
        {}}

\DeclareDocumentCommand \HashWalk {m +m}
    {\prop_if_exist:cTF      {g_UWMad_Hash_#1}
        {\prop_map_inline:cn {g_UWMad_Hash_#1}
            {#2}}
        {}}

\DeclareDocumentCommand \HashDelete { m }
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}
        {\prop_gclear:c {g_UWMad_Hash_#1}
         \cs_undefine:c {g_UWMad_Hash_#1}}
        {}}
%
%
%
\ExplSyntaxOff
%</Module:Programming>
%Verbatim
%</Implementation>