%<*UserGuide>
%
%   \subsection{Programming}\label{UG:Programming}
%   The Programming Module has no immediate user-facing features.
%   The Implementation section for this module outlines the programming layer
%   and is aimed mainly at authors that wish to utilize its abilities.
%
%</UserGuide>
%
%
%
%<*Implementation>
%<<Implementation
%%
%%  Module Name: Programming
%%  Author:
%%      Name:           Troy C. Haskin
%%      E-mail:         UWMadThesis@hask.in
%%  Version:
%%      Number:         1.0
%%      Description:    Initial release
%%      Date:           06/01/2013
%%  Purpose:
%%      Provide a programming layer for the UW-Madison Thesis package
%%      Most of the module is designed to overcome the lack of such a
%%      layer in LaTeX2e.  Some LaTeX3 is being used for certain advanced
%%      features, and this module may become obsolete when/if it is upgraded
%%      to a pure LaTeX3 implementation.
%
%   \subsection{Programming Module}\labe{Imp:Programming}
%   This section outlines the Programming module for the \UWMadClass.
%   It is mostly a collection of utility macros used in other modules.
%   The two biggest features in this module are the Array and Hash 
%   (associative arrays) systems used a other modules.  Those features 
%   are near the end of this subsection.
%
%   The commands are currently a mix of \TeX{}, \LaTeX2e{}, and \LaTeX3{}.
%   Pure \TeX{} is used only where the other features have no such facility
%   for the intended purpose.  Also, the |etoolbox| package is used as
%   the basis for many of the utility macros, and those macros are actually,
%   for all intents and purposes, just aliases for etoolbox commands. This
%   method was chosen to allow for an easier transition to another system.
%
%
%
%   \subsubsection{Utility Macros}
%
%   \begin{macro}{\GlobalNewIf}
%   Changes to if-switches only have block level scope by default.
%   Therefore, switches generated by |\newif| revert to their pre-block
%   state upon exiting a block regardless of any non-global changes within
%   the block.  This command creates an if-switch pair that has inherent
%   global scope.
%
%   \begin{Usage}
%       \item{|\GlobalNewIf|\marg{SwitchName}}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\GlobalNewIf}[1]{%
    \csgdef{#1true}%
        {\global\cslet{if#1}{\iftrue}}
    \csgdef{#1false}%
        {\global\cslet{if#1}{\iffalse}}}%
%    \end{macrocode}
%   \end{macro}
%
%
%   \begin{macro}{\IfCommandExists}
%   \begin{macro}{\IfCommandDoesNotExist}
%   This command pair is used instead of \LaTeX{}'s |\@ifundefined|.
%   Since it is \eTeX{}, this command will allow for a switch to
%   |\@ifundefined| if problems arise from non-\eTeX{} users in the
%   future.
%
%   \begin{Usage}
%       \item |\IfCommandExists|\marg{Command Name}\marg{True}\marg{False}
%       \item |\IfCommandDoesNotExist|\marg{Command Name}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfCommandExists}[3]{%
    \ifcsname#1\endcsname%
        #2%
    \else%
        #3%
    \fi}
\newcommand{\IfCommandDoesNotExist}[3]{%
    \ifcsname#1\endcsname%
        #3%
    \else%
        #2%
    \fi}%
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%   \begin{macro}{\IfGreaterThanEqualTo}
%   \begin{macro}{\IfLessThanEqualTo}
%   This set of commands uses \TeX{} primitives to allow conditional code
%   execution of the variety: \marg{Oper1} $\geq$ \marg{Oper2} and 
%                             \marg{Oper1} $\leq$ \marg{Oper2}.
%
%   \begin{Usage}
%       \item |\IfGreaterThanEqualTo|\marg{Oper1}\marg{Oper2}\marg{True}\marg{False}
%       \item |\IfLessThanEqualTo|\marg{Oper1}\marg{Oper2}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfGreaterThanEqualTo}[4]{%
    \ifnum#1>#2%
        #3%
    \else%
        \ifnum#1=#2%
            #3%
        \else%
            #4%
        \fi%
    \fi}
\newcommand{\IfLessThanEqualTo}[4]{%
    \ifnum#1<#2%
        #3%
    \else%
        \ifnum#1=#2%
            #3%
        \else%
            #4%
        \fi%
    \fi}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%   \begin{macro}{\IfStringEmpty}
%   Checks if a given string is empty.
%   It uses the |etoolbox| command |\ifblank|.
%   This command will not expand the string input.
%
%   \begin{Usage}
%       |\IfStringEmpty|\marg{String}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfStringEmpty}[3]{%
    \ifblank{#1}%
        {#2}%
        {#3}}
%    \end{macrocode}
%   \end{macro}
%
%
%   \begin{macro}{\IfCommandEmpty}
%   Uses the |etoolbox|'s |\ifdefempty| command to test if a command expands
%   to an empty string and is followed by the given conditional code.
%
%   \begin{Usage}
%       \item |IfCommandEmpty|\marg{Command}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfCommandEmpty}[3]{%
    \ifdefempty{#1}%
        {#2}%
        {#3}}
%    \end{macrocode}
%   \end{macro}
%
%
%   \subsubsection{Command Creator System}
%   \begin{macro}{\MakeCommand}
%    Uses the |etoolbox|'s |\csdef| to define a command via a string
%   and a set of code.
%
%   \begin{Usage}
%       \item |\MakeCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\MakeCommand}[2]{%
    \csdef{#1}{#2}}
%   \end{macrocode}
%   \end{macro}
%
%
\newcommand{\ReMakeCommand}[2]{
    \IfCommandExists{#1}%
        {\csdef{#1}{#2}}%
        {\UWMad@ClassWarning{Command '#1' is undefined; could not define.}}}

\newcommand{\MakeFullyExpandedCommand}[2]{%
    \csxdef{#1}{#2}}

\newcommand{\MakeExpandedCommand}[2]{%
    \protected@csxdef{#1}{#2}}

\newcommand{\CopyCommand}[2]{%
    \cslet{#1}{#2}}

\newcommand{\MakeGlobalCommand}[2]{%
    \csgdef{#1}{#2}}


\newcommand{\MakeCommandUndefined}[1]{% #1 = Command name
    \global\csundef{#1}}




\newcommand{\MakeCounterUndefined}[1]{% #1 = Counter name
    \MakeCommandUndefined{#1}}

% This is a convenience command used to define a new length and set its initial value.
% A thin abstraction that declares and intializes dimensions.
\newcommand{\DefineNewLength}[2]{
    \newlength{#1}
    \setlength{#1}{#2}}

% This is a convenience command used to define a new counter and set its initial value.
% A thin abstraction that declares and intializes lengths.
\newcommand{\DefineNewCounter}[2]{
    \newcounter{#1}
    \setcounter{#1}{#2}
}


% =========================================================================== %
%                    New Counter System: Local and Global                     %
% =========================================================================== %
\newcommand{\UWMad@CounterSuffixLocal} {LOCAL COUNTER}
\newcommand{\UWMad@CounterSuffixGlobal}{GLOBAL COUNTER}

%   Declare a new local counter (meaning that changes to its value only 
%   persist for the current group/scope) using the TeX \newcount
\newcommand{\DefineNewLocalCounter}[2]{%
    \MakeCommand{#1\UWMad@CounterSuffixLocal}{}
    \expandafter\newcount\csname#1\endcsname%
    \csname#1\endcsname=#2%
}

%   Declare a new global counter (meaning that changes to its value 
%   persist for all groups/scopes) using the LaTeX \newcounter
\newcommand{\DefineNewGlobalCounter}[2]{%
    \MakeCommand{#1\UWMad@CounterSuffixGlobal}{}%
    \expandafter\newcount\csname#1\endcsname%
    \csname#1\endcsname=#2%
}

%   Use the etoolbox commands to determine if the counter name
%   passed is a local (TeX) or global (LaTeX) counter
\newcommand{\LocalGlobalHandler}[1]{%
    \IfCommandExists{#1\UWMad@CounterSuffixGlobal}%
        {\let\UWMad@PreCounter\global}%
        {\IfCommandExists{#1\UWMad@CounterSuffixLocal}%
            {\let\UWMad@PreCounter\relax}%
            {\UWMad@ClassWarning%
                {This is not a local or global counter '#1'}}}}

%   Increment the counter by #2 basedermine if the counter name
%   passed is a local (TeX) or global (LaTeX) counter
\newcommand{\AddToCounter}[2]{
    \LocalGlobalHandler{#1}%
    \expandafter\UWMad@PreCounter\expandafter\advance\csname#1\endcsname #2%
}

%   Increment the counter by 1 basedermine if the counter name
%   passed is a local (TeX) or global (LaTeX) counter
\newcommand{\StepCounter}[1]{%
    \AddToCounter{#1}{1}%
}

\newcommand{\SetCounter}[2]{
    \LocalGlobalHandler{#1}%
    \expandafter\UWMad@PreCounter\csname#1\endcsname=#2%
}

\newcommand{\SetAndAddToCounter}[3]{%
    \SetCounter{#1}{#2}%
    \AddToCounter{#1}{#3}%
}

\newcommand{\SetAndStepCounter}[2]{%
    \SetCounter{#1}{#2}%
    \AddToCounter{#1}{1}%
}

\newcommand{\CounterValue}[1]{%
    \the\csuse{#1}%
}

\DefineNewGlobalCounter{WorkCounter}{0}





% A environment that allows for global defintions.
\newenvironment{MakeGlobal}{\globaldefs=1}{\globaldefs=0}

\def\Show#1{
    {
    \edef\ExpandedArgument{#1}
    \show\ExpandedArgument
    }
}

 \newcommand{\Trim}[1]{\ignorespaces#1\unskip} 



% =========================================================================== %
%                          CSV Creation Commands                              %
% =========================================================================== %
\newcommand{\CSVSuffix}{CSV LIST}

\newcommand{\IfCSVExists}[3]{%
    \IfCommandExists{#1\CSVSuffix}%
    {#2}%
    {#3}%
}

\newcommand{\CSVMake}[1]{ % #1 = List name, #2 = Token to push on to right
    \IfCSVExists{#1}
        {\UWMad@ClassWarning{CSV '#1' already exists.}}
        {\MakeCommand{#1\CSVSuffix}{}}
}

\newcommand{\CSVAppend}[2]{ % #1 = List name, #2 = Token to push on to right
     \IfCSVExists{#1}
        {\ifcsempty{#1\CSVSuffix}
            {\protected@csxdef{#1\CSVSuffix}{#2}}
            {\protected@csxdef{#1\CSVSuffix}{\csuse{#1\CSVSuffix},#2}}}
        {\CSVMake{#1}
         \CSVAppend{#1}{#2}}
}

\newcommand{\CSVPrepend}[2]{ % #1 = List name, #2 = Token to push on to left
     \IfCSVExists{#1}
        {\ifcsempty{#1\CSVSuffix}
            {\protected@csxdef{#1\CSVSuffix}{#2}}
            {\protected@csxdef{#1\CSVSuffix}{#2,\csuse{#1\CSVSuffix}}}}
        {\CSVMake{#1}
         \CSVPrepend{#1}{#2}}
}

\newcommand{\CSVGet}[1]{% #1 = List name, #2 = Token to push on to left
     \IfCSVExists{#1}%
        {\csuse{#1\CSVSuffix}}%
        {}%
}






% =========================================================================== %
%                      Array Building Commands                                %
% =========================================================================== %

\DefineNewCounter{ArrayWorkCounter}{0}
\newcommand{\ArraySuffix}         {ARRAY}
\newcommand{\ArraySuffixStart}    {\ArraySuffix START   }
\newcommand{\ArraySuffixEnd}      {\ArraySuffix END     }
\newcommand{\ArraySuffixPosition} {\ArraySuffix POSITION}
\newcommand{\ArraySuffixCount}    {\ArraySuffix COUNT   }

\newcommand{\ArrayMake}[1]{% #1 = Array name
    \MakeGlobalCommand{#1\ArraySuffix}             {#1\ArraySuffix}
    \DefineNewGlobalCounter{#1\ArraySuffixPosition} {0}
    \DefineNewGlobalCounter{#1\ArraySuffixStart}    {1}
    \DefineNewGlobalCounter{#1\ArraySuffixEnd}      {0}
    \DefineNewGlobalCounter{#1\ArraySuffixCount}    {0}
}


% Counter names for a given array
\newcommand{\ArrayPosition}[1]{#1\ArraySuffixPosition} % #1 = ArrayName
\newcommand{\ArrayStart}   [1]{#1\ArraySuffixStart}    % #1 = ArrayName
\newcommand{\ArrayEnd}     [1]{#1\ArraySuffixEnd}      % #1 = ArrayName
\newcommand{\ArrayCount}   [1]{#1\ArraySuffixCount}    % #1 = ArrayName
% Counter names for a given array
\newcommand{\ArrayNumberPosition}[1]{\csname#1\ArraySuffixPosition\endcsname}  % #1 = ArrayName
\newcommand{\ArrayNumberStart}   [1]{\csname#1\ArraySuffixStart\endcsname}    % #1 = ArrayName
\newcommand{\ArrayNumberEnd}     [1]{\csname#1\ArraySuffixEnd\endcsname}      % #1 = ArrayName
\newcommand{\ArrayNumberCount}   [1]{\csname#1\ArraySuffixCount\endcsname}    % #1 = ArrayName
% Decrementers
\newcommand{\ArrayDecrementPosition}[1]{\AddToCounter{\ArrayPosition{#1}}{-1}}
\newcommand{\ArrayDecrementStart}   [1]{\AddToCounter{\ArrayStart   {#1}}{-1}}
\newcommand{\ArrayDecrementEnd}     [1]{\AddToCounter{\ArrayEnd     {#1}}{-1}}
\newcommand{\ArrayDecrementCount}   [1]{\AddToCounter{\ArrayCount   {#1}}{-1}}
% Incrementers
\newcommand{\ArrayIncrementPosition}[1]{\AddToCounter{\ArrayPosition{#1}}{+1}}
\newcommand{\ArrayIncrementStart}   [1]{\AddToCounter{\ArrayStart   {#1}}{+1}}
\newcommand{\ArrayIncrementEnd}     [1]{\AddToCounter{\ArrayEnd     {#1}}{+1}}
\newcommand{\ArrayIncrementCount}   [1]{\AddToCounter{\ArrayCount   {#1}}{+1}}
% Numerical values
\newcommand{\ArrayValuePosition}[1]{\CounterValue{#1\ArraySuffixPosition}} % #1 = Array name
\newcommand{\ArrayValueStart}   [1]{\CounterValue{#1\ArraySuffixStart}}    % #1 = Array name
\newcommand{\ArrayValueEnd}     [1]{\CounterValue{#1\ArraySuffixEnd}}      % #1 = Array name
\newcommand{\ArrayValueCount}   [1]{\CounterValue{#1\ArraySuffixCount}}    % #1 = Array name
% Use the array entry given a counter set to the desired index
\newcommand{\ArrayUse}[2]{\csuse{#1\ArraySuffix\CounterValue{#2}}}


\newcommand{\ArrayDelete}[1]{% #1 = Array name
    \ForEach{#1}{
        \MakeCommandUndefined{#1\ArraySuffix\CounterValue{ForLoopCounter}}
    }
    \MakeCommandUndefined{#1\ArraySuffix}
    \MakeCounterUndefined{#1\ArraySuffixPosition}
    \MakeCounterUndefined{#1\ArraySuffixStart}
    \MakeCounterUndefined{#1\ArraySuffixEnd}
    \MakeCounterUndefined{#1\ArraySuffixCount}
}

\newcommand{\ArrayReset}[1]{% #1 = Array name
    \ForEach{#1}{
        \MakeCommandUndefined{#1\ArraySuffix\CounterValue{ForLoopCounter}}
    }
    \SetCounter{#1\ArraySuffixPosition} {0}
    \SetCounter{#1\ArraySuffixStart}    {1}
    \SetCounter{#1\ArraySuffixEnd}      {0}
    \SetCounter{#1\ArraySuffixCount}    {0}
}

\newcommand{\ArrayPush}[2]{% #1 = Array name, #2 value to push

    % increment counters
    \ArrayIncrementCount{#1}
    \ArrayIncrementEnd  {#1}

    % Naming scheme for the Array storage commands: <Name>\roman{<Counter>}
    \MakeCommand{#1\ArraySuffix\ArrayValueEnd{#1}}{#2}%
}

\newcommand{\ArrayPop}[1]{% #1 = Array name
    \ifnum\ArrayNumberCount{#1}>0%
        \ArrayUse{#1}{\ArrayEnd{#1}}%
        \MakeCommandUndefined{#1\ArraySuffix\ArrayValueEnd{#1}}%
        % decrement counters
        \ArrayDecrementCount{#1}%
        \ArrayDecrementEnd  {#1}%
    \fi%
}

\newcommand{\ArrayPopAndStore}[2]{% #1 = Array name, #2 name of command to store the popped value
    \ifnum\ArrayNumberCount{#1}>0%
        \MakeExpandedCommand{#2}{\ArrayUse{#1}{\ArrayEnd{#1}}}%
        \MakeCommandUndefined{#1\ArraySuffix\ArrayValueEnd{#1}}%
        % decrement counters
        \ArrayDecrementCount{#1}
        \ArrayDecrementEnd  {#1}
    \fi
}

\newcommand{\ArrayGet}[2]{% #1 = Array name, % 2 = Counter Name for index
    %\IfArrayExists{#1}%
        %{\IfArrayIndexDefined{#1}{#2}%
            %{
            %\ArrayUse{#1}{#2}}%
        %    {\UWMad@ClassWarning{Index for array '#1' is undefined.}}}%
        %{}%
    \csname#1\ArraySuffix\CounterValue{#2}\endcsname
}

\newcommand{\IfArrayIndexDefined}[4]{% #1 = Array name, % #2 = numeric value, % #3 = True code, % #4 = False code
    \IfCommandExists{#1\ArraySuffix\CounterValue{#2}}%
        {#3}%
        {#4}%
}

\newcommand{\IfArrayIndexNotDefined}[4]{% #1 = Array name, % #2 = numeric value, % #3 = True code, % #4 = False code
    \IfCommandExists{#1\ArraySuffix\CounterValue{#2}}%
        {#4}%
        {#3}%
}%

\newcommand{\IfArrayExists}[3]{% #1 = Array name, #2 = True code, #3 = False code
    \IfCommandExists{#1\ArraySuffix}%
        {#2}%
        {#3}%
}%




% =========================================================================== %
%                 Hashes (Associative Arrays) with LaTeX3                     %
% =========================================================================== %


% ************ LaTeX3 ON ************ %
\ExplSyntaxOn

\DeclareDocumentCommand \HashMake {m}%
    {\prop_new:c {g_UWMad_Hash_#1}}

\DeclareDocumentCommand \HashSet {mmm}%
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}%
      {\prop_gput:cnn   {g_UWMad_Hash_#1}{#2}{#3}}%
        {\HashMake{#1}%
         \prop_gput:cnn {g_UWMad_Hash_#1}{#2}{#3}}}

\DeclareDocumentCommand \HashGet {mm}%
    {\prop_if_exist:cTF  {g_UWMad_Hash_#1}%
        {\prop_get:cn {g_UWMad_Hash_#1} {#2}}
        {}}

\cs_generate_variant:Nn \prop_get:cn {cf}

\DeclareExpandableDocumentCommand \HashExpandableGet {mm}%
    {\prop_if_exist:cTF  {g_UWMad_Hash_#1}%
        {\prop_get:cf {g_UWMad_Hash_#1} {#2}}
        {}}

\DeclareDocumentCommand \HashUnset {mm}%
    {\prop_if_exist:cTF    {g_UWMad_Hash_#1}%
        {\prop_get:cnNTF   {g_UWMad_Hash_#1} {#2} \l_UWMad_Hash_Value_tl%
            {\prop_gdel:cn {g_UWMad_Hash_#1} {#2}}
            {}}}

\DeclareDocumentCommand \IfHashKeySet {mmmm}%
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}%
        {\prop_if_in:cnTF {g_UWMad_Hash_#1} {#2}
            {#3}
            {#4}}
        {}}

\DeclareDocumentCommand \HashDelete {m}%
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}%
        {\prop_gclear:c {g_UWMad_Hash_#1}%
         \cs_undefine:c {g_UWMad_Hash_#1}}
        {}}

\ExplSyntaxOff
% ************ LaTeX3 OFF *********** %






% =========================================================================== %
%                            For-Loop Definition                              %
% =========================================================================== %


% Initilaze the recursive command (see usage below) ----------------------
\newcommand{\ForLoopRecursion}{}

% Define the loop counter ------------------------------------------------
\DefineNewLocalCounter{ForLoopCounter}{0}

% Iterator command -------------------------------------------------------
\newcommand{\For}[4][1]{%
    {%
    % Arguments
    %   #1 = increment (optional)
    %   #2 = start value
    %   #3 = end value
    %   #4 = <code>
    % Redefine the command used for recursion
    \renewcommand{\ForLoopRecursion}{%
        #4%                                         % Excute <code>
        \AddToCounter{ForLoopCounter}{#1}%          % Increment the counter
        \For[#1]{\number\ForLoopCounter}{#3}{#4}%   % Recurse
    }%
    %
    % Set the counter to the start value 
    % After the recursion begins, #2 is the current value of the counter and not the start value.
    \SetCounter{ForLoopCounter}{#2}%
    %
    % Switch to deal with positive vs. negative increments (decrements).
    \ifnum #1 > 0%                                    % If positive increment
        \IfLessThanEqualTo{\ForLoopCounter}{#3}{%     % Execute while the LoopCounter is less than or equal to the end value
            \ForLoopRecursion%
        }{}%
    \else%                                                   % If negative increment
        \IfGreaterThanEqualTo{\ForLoopCounter}{#3}{%   % Execute while the LoopCounter is greater than or equal to the end value
            \ForLoopRecursion%
        }{}%
    \fi%
    }%
}


\newcommand{\ForEach}[3][1]{
% Arguments
%   #1 = increment (optional)
%   #2 = Array/Hash name
%   #3 = <code>
    %
    \IfCommandExists{#2\ArraySuffix}{%
        \For[#1]{\ArrayNumberStart{#2}}{\ArrayNumberEnd{#2}}{#3}%
    }{%
        %\IfCommandExists{#2\HashSuffix}{%
        %    \For[#1]{\ArrayNumberStart{#2\HashSuffixKeys}}{\ArrayNumberEnd{#2\HashSuffixKeys}}{#3}%
        %}{%
            \UWMad@ClassWarning{Could not find Array or Hash named '#2'}%
        %}%
    }%
}
%
%
%ModuleImplementation
%</Implementation>