%<*UserGuide>
\ifUWMad@UserGuide

\subsection{Programming}\label{UG:Programming}
The Programming Module has no immediate user-facing features.
The Implementation section for this module outlines the programming layer
and is aimed mainly at authors that wish to utilize its abilities.

\fi
%</UserGuide>
%
%
%
%<*Implementation>
%<<Verbatim
%<*Module:Programming>
%
%^^A
%^^A  Module Name: Programming
%^^A  Author:
%^^A    Name:           Troy C. Haskin
%^^A    E-mail:         UWMadThesis@hask.in
%^^A  Version:
%^^A    Number:         1.0
%^^A    Description:    Initial release
%^^A    Date:           06/01/2013
%^^A  Purpose:
%^^A    Provide a programming layer for the UW-Madison Thesis package
%^^A    Most of the module is designed to overcome the lack of such a
%^^A    layer in LaTeX2e.  Some LaTeX3 is being used for certain advanced
%^^A    features, and this module may become obsolete when/if it is upgraded
%^^A    to a pure LaTeX3 implementation; though a thin abatraction layer may
%^^A    still be desired.
%
%   \subsection{Programming Module}\label{Imp:Programming}
%   This section outlines the Programming module for the \UWMadClass.
%   It is mostly a collection of utility macros used in other modules.
%   The two biggest features in this module are the Array and Hash 
%   (associative arrays) systems used a other modules.  Those features 
%   are near the end of this subsection.
%
%   The commands are currently a mix of \TeX{}, \LaTeX2e{}, and \LaTeX3{}.
%   Pure \TeX{} is used only where the other features have no such facility
%   for the intended purpose.  Also, the |etoolbox| package is used as
%   the basis for many of the utility macros, and those macros are actually,
%   for all intents and purposes, just aliases for etoolbox commands. This
%   method was chosen to allow for an easier transition to another system.
%
%
%^^A ==================================================================== %
%^^A                            Utility Macros                            %
%^^A ==================================================================== %
%
%   \subsubsection{Utility Macros}
%
%   \begin{macro}{\GlobalNewIf}
%   Changes to if-switches only have block level scope by default.
%   Therefore, switches generated by |\newif| revert to their pre-block
%   state upon exiting a scope regardless of any non-global changes within
%   the block.  This command creates an if-switch pair that has inherent
%   global scope.
%
%   \begin{Usage}
%       \item |\GlobalNewIf|\marg{SwitchName}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\GlobalNewIf}[1]{%
    \csgdef{#1true}%
        {\global\cslet{if#1}{\iftrue}}%
    \csgdef{#1false}%
        {\global\cslet{if#1}{\iffalse}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfCommandExists}
%   \begin{macro}{\IfCommandDoesNotExist}
%   This command pair is used instead of \LaTeX{}'s |\@ifundefined|.
%   Since it is \eTeX{}, this command will allow for a switch to
%   |\@ifundefined| if problems arise from non-\eTeX{} users in the
%   future.
%
%   \begin{Usage}
%       \item |\IfCommandExists|\marg{Command Name}\marg{True}\marg{False}
%       \item |\IfCommandDoesNotExist|\marg{Command Name}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfCommandExists}[3]{%
    \ifcsname#1\endcsname%
        #2%
    \else%
        #3%
    \fi}
\newcommand{\IfCommandDoesNotExist}[3]{%
    \ifcsname#1\endcsname%
        #3%
    \else%
        #2%
    \fi}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfGreaterThanEqualTo}
%   \begin{macro}{\IfLessThanEqualTo}
%   This set of commands uses \TeX{} primitives to allow conditional code
%   execution of the variety: \marg{Oper1} $\geq$ \marg{Oper2} and 
%                             \marg{Oper1} $\leq$ \marg{Oper2}.
%
%   \begin{Usage}
%       \item |\IfGreaterThanEqualTo|\marg{Oper1}\marg{Oper2}\marg{True}\marg{False}
%       \item |\IfLessThanEqualTo|\marg{Oper1}\marg{Oper2}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfGreaterThanEqualTo}[4]{%
    \ifnum#1>#2%
        #3%
    \else%
        \ifnum#1=#2%
            #3%
        \else%
            #4%
        \fi%
    \fi}
\newcommand{\IfLessThanEqualTo}[4]{%
    \ifnum#1<#2%
        #3%
    \else%
        \ifnum#1=#2%
            #3%
        \else%
            #4%
        \fi%
    \fi}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfStringEmpty}
%   Checks if a given string is empty.
%   It uses the |etoolbox|'s |\ifblank|.
%   This command will not expand input.
%
%   \begin{Usage}
%       \item |\IfStringEmpty|\marg{String}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfStringEmpty}[3]{%
    \ifblank{#1}%
        {#2}%
        {#3}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\IfCommandEmpty}
%   Uses the |etoolbox|'s |\ifdefempty| command to test if a command expands
%   to an empty string and is followed by the given conditional code.
%
%   \begin{Usage}
%       \item |IfCommandEmpty|\marg{Command}\marg{True}\marg{False}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\IfCommandEmpty}[3]{%
    \ifdefempty{#1}%
        {#2}%
        {#3}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewLength}
%   This is a convenience command used to define a new length
%   \marg{Length Name} and set its \marg{Value}.
%
%   \begin{Usage}
%       \item |DefineNewLength|\marg{Length Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\DefineNewLength}[2]{%
    \newlength{#1}%
    \setlength{#1}{#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewCounter}
%   This is a convenience command used to define a new \LaTeX{} counter
%   \marg{Counter Name} and set its \marg{Value}.
%
%   \begin{Usage}
%       \item |DefineNewCounter|\marg{Counter Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\DefineNewCounter}[2]{%
    \newcounter{#1}%
    \setcounter{#1}{#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                      Command Creator System                          %
%^^A ==================================================================== %
%
%   \subsubsection{Command Creator System}
%
%   \begin{macro}{\MakeCommand}
%   \begin{macro}{\ReMakeCommand}
%   This command pair uses the |etoolbox|'s |\csdef| to define a commands
%   via a supplied string \marg{Command Name} and a set of \marg{Code}.
%   If the requested command is not defined, |\MakeCommand| will create it;
%   however, if the requested command is already defined, |\MakeCommand| will
%   throw a warning and not make the command.
%   If the requested command is defined, |\ReMakeCommand| will redefine it;
%   however, if the requested command is not defined, |\ReMakeCommand| will
%   throw a warning and not make the command.
%
%   \begin{Usage}
%       \item |\MakeCommand|\marg{Command Name}\marg{Code}
%       \item |\ReMakeCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\MakeCommand}[2]{%
    \IfCommandDoesNotExist{#1}%
        {\csdef{#1}{#2}}%
        {\UWMad@ClassWarning{Command `#1' is already defined.}}}
\newcommand{\ReMakeCommand}[2]{%
    \IfCommandExists{#1}%
        {\csdef{#1}{#2}}%
        {\UWMad@ClassWarning{Command `#1' is undefined.}}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeGlobalCommand}
%   Similar to |\MakeCommand| except the creation is made regardless of the
%   requested command's definition and the creation is global.
%
%   \begin{Usage}
%       \item |\MakeGlobalCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\MakeGlobalCommand}[2]{%
    \csgdef{#1}{#2}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeExpandedCommand}
%   \begin{macro}{\MakeFullyExpandedCommand}
%   This command pair creates commands in the spirit of |\MakeCommand|
%   but with several differences.  First, the commands simply create
%   the requested command without regard to its existence.  Secondly,
%   the \marg{Code} supplied is expanded with protection by 
%   |\MakeExpandedCommand| and fully expanded by |\MakeFullyExpandedCommand|.
%   Lastly, the definitions are global.
%
%   \begin{Usage}
%       \item |\MakeExpandedCommand|\marg{Command Name}\marg{Code}
%       \item |\MakeFullyExpandedCommand|\marg{Command Name}\marg{Code}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\MakeExpandedCommand}[2]{%
    \protected@csxdef{#1}{#2}}
\newcommand{\MakeFullyExpandedCommand}[2]{%
    \csxdef{#1}{#2}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeCommandUndefined}
%   Globally undefines the command specified by \marg{Command Name}.
%
%   \begin{Usage}
%       \item |\MakeCommandUndefined|\marg{Command Name}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\MakeCommandUndefined}[1]{%
    \global\csundef{#1}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\CopyCommand}
%   Copies the defintion of the command named \marg{Command Name 1} to 
%   a new command named \marg{Command Name 2}.  If \marg{Command Name 2}
%   already has a definition, |\CopyCommand| will throw a warning
%   \emph{but} still make the copy.
%
%   \begin{Usage}
%       \item |\CopyCommand|\marg{Command Name 1}\marg{Command Name 2}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\CopyCommand}[2]{%
    \IfCommandExists{#1}%
        {\IfCommandExists{#2}%
            {\UWMad@ClassWarning{Command `#2' is defined.}}%
            {}%
            \csletcs{#2}{#1}}%
        {\UWMad@ClassWarning{Command `#1' is undefined.}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
%^^A ==================================================================== %
%^^A                            Counter System                            %
%^^A ==================================================================== %
%
%   \subsubsection{Counter System}
%   This subsystem was made to give a \LaTeX{}-like counter system that
%   can create both local and global counters.
%
%   \begin{macro}{\UWMad@RegisteredCounter}
%   \begin{macro}{\UWMad@LocalCounter}
%   \begin{macro}{\UWMad@GlobalCounter}
%   These commands define the command name suffixes used to store, identify,
%   and protect (from the user) the counter commands.  All counters created
%   by the system are given a registration command to indicate it is part of
%   the system and either a local or global command to indicate if a |\global|
%   prefix is needed for assignment and advancement.  The counter itself is
%   created without any prefix or suffix for usage by the user.
%
%    \begin{macrocode}
\newcommand{\UWMad@RegisteredCounter} {UWMad@RegisteredCounter}
\newcommand{\UWMad@LocalCounter}      {UWMad@LocalCounter}
\newcommand{\UWMad@GlobalCounter}     {UWMad@GlobalCounter}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\DefineNewLocalCounter}
%   \begin{macro}{\DefineNewGlobalCounter}
%   This pair creates either a local or global counter named
%   \marg{Counter Name} with \marg{Initial Value}. The counters
%   are registered, defined to be local or global, initialized
%   by |\newcount|, and set to \marg{Initial Value}.
%
%   \begin{Usage}
%       \item |\DefineNewLocalCounter|\marg{Counter Name}{Initial Value}
%       \item |\DefineNewGlobalCounter|\marg{Counter Name}{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\DefineNewLocalCounter}[2]{%
    \MakeCommand{#1\UWMad@RegisteredCounter}{}%
    \MakeCommand{#1\UWMad@LocalCounter}{}%
    \expandafter\newcount\csname#1\endcsname%
    \csname#1\endcsname=#2}
\newcommand{\DefineNewGlobalCounter}[2]{%
    \MakeCommand{#1\UWMad@RegisteredCounter}{}%
    \MakeCommand{#1\UWMad@GlobalCounter}{}%
    \expandafter\newcount\csname#1\endcsname%
    \csname#1\endcsname=#2}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\UWMad@LocalOrGlobal}
%   This command expands to either |\global| or |\relax| depending on the
%   definition of the counter \marg{Counter Name}.
%
%   \begin{Usage}
%       \item |\UWMad@LocalOrGlobal|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\UWMad@LocalOrGlobal}[1]{%
    \IfCommandExists{#1\UWMad@GlobalCounter}%
        {\global}%
        {\relax}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\AddToCounter}
%   This command adds \marg{Increment} to the current value of counter
%   \marg{Counter Name}. |\UWMad@LocalOrGlobal| handles the local vs.
%   global advancement.
%
%   \begin{Usage}
%       \item |\AddToCounter|\marg{Counter Name}\marg{Increment}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\AddToCounter}[2]{%
    \IfCommandExists{#1\UWMad@RegisteredCounter}
        {\expandafter%
            \UWMad@LocalOrGlobal{#1}%
                \expandafter%
                    \advance\csname#1\endcsname #2}
        {\UWMad@ClassWarning{`#1' is not a registered counter.}}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\StepCounter}
%   Adds $1$ to the counter \marg{Counter Name}.
%   |\UWMad@LocalOrGlobal| handles the local vs. global advancement.
%
%   \begin{Usage}
%       \item |\StepCounter|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\StepCounter}[1]{%
    \AddToCounter{#1}{1}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\SetCounter}
%   This command sets the value of counter \marg{Counter Name} to \marg{Value}.
%   |\UWMad@LocalOrGlobal| handles the local vs. global assignment.
%
%   \begin{Usage}
%       \item |\SetCounter|\marg{Counter Name}\marg{Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\SetCounter}[2]{%
    \expandafter%
        \UWMad@LocalOrGlobal{#1}%
            \expandafter%
                \csname#1\endcsname=#2}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\SetAndAddToCounter}
%   \begin{macro}{\SetAndStepCounter}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%
%   \begin{Usage}
%       \item |\SetAndAddToCounter|\marg{Counter Name}\marg{Initial Value}\marg{Value}
%       \item |\SetAndStepCounter|\marg{Counter Name}\marg{Initial Value}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\SetAndAddToCounter}[3]{%
    \SetCounter{#1}{#2}%
    \AddToCounter{#1}{#3}}
\newcommand{\SetAndStepCounter}[2]{%
    \SetCounter{#1}{#2}%
    \AddToCounter{#1}{1}}
%    \end{macrocode}
%   \end{macro}
%   \end{macro}
%
%
%
%   \begin{macro}{\CounterValue}
%   Combinations of |\SetCounter|, |AddToCounter|, and |\StepCounter|.
%
%   \begin{Usage}
%       \item |\CounterValue|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\CounterValue}[1]{%
    \the\csuse{#1}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%   \begin{macro}{\MakeCounterUndefined}
%   Erases the counter \marg{Counter Name} from the system. 
%
%   \begin{Usage}
%       \item |\MakeCounterUndefined|\marg{Counter Name}
%   \end{Usage}
%
%    \begin{macrocode}
\newcommand{\MakeCounterUndefined}[1]{%
    \MakeCommandUndefined{#1\UWMad@RegisteredCounter}%
    \MakeCommandUndefined{#1\UWMad@LocalCounter}%
    \MakeCommandUndefined{#1\UWMad@GlobalCounter}}
%    \end{macrocode}
%   \end{macro}
%
%
%
%
%
%
% =========================================================================== %
%                          CSV Creation Commands                              %
% =========================================================================== %
\newcommand{\CSVSuffix}{CSV LIST}

\newcommand{\IfCSVExists}[3]{%
    \IfCommandExists{#1\CSVSuffix}%
    {#2}%
    {#3}%
}

\newcommand{\CSVMake}[1]{ % #1 = List name, #2 = Token to push on to right
    \IfCSVExists{#1}
        {\UWMad@ClassWarning{CSV '#1' already exists.}}
        {\MakeCommand{#1\CSVSuffix}{}}
}

\newcommand{\CSVAppend}[2]{ % #1 = List name, #2 = Token to push on to right
     \IfCSVExists{#1}
        {\ifcsempty{#1\CSVSuffix}
            {\protected@csxdef{#1\CSVSuffix}{#2}}
            {\protected@csxdef{#1\CSVSuffix}{\csuse{#1\CSVSuffix},#2}}}
        {\CSVMake{#1}
         \CSVAppend{#1}{#2}}
}

\newcommand{\CSVPrepend}[2]{ % #1 = List name, #2 = Token to push on to left
     \IfCSVExists{#1}
        {\ifcsempty{#1\CSVSuffix}
            {\protected@csxdef{#1\CSVSuffix}{#2}}
            {\protected@csxdef{#1\CSVSuffix}{#2,\csuse{#1\CSVSuffix}}}}
        {\CSVMake{#1}
         \CSVPrepend{#1}{#2}}
}

\newcommand{\CSVGet}[1]{% #1 = List name, #2 = Token to push on to left
     \IfCSVExists{#1}%
        {\csuse{#1\CSVSuffix}}%
        {}%
}






% =========================================================================== %
%                      Array Building Commands                                %
% =========================================================================== %

\DefineNewCounter{ArrayWorkCounter}{0}
\newcommand{\ArraySuffix}         {ARRAY}
\newcommand{\ArraySuffixStart}    {\ArraySuffix START   }
\newcommand{\ArraySuffixEnd}      {\ArraySuffix END     }
\newcommand{\ArraySuffixPosition} {\ArraySuffix POSITION}
\newcommand{\ArraySuffixCount}    {\ArraySuffix COUNT   }

\newcommand{\ArrayMake}[1]{% #1 = Array name
    \MakeGlobalCommand{#1\ArraySuffix}             {#1\ArraySuffix}
    \DefineNewGlobalCounter{#1\ArraySuffixPosition} {0}
    \DefineNewGlobalCounter{#1\ArraySuffixStart}    {1}
    \DefineNewGlobalCounter{#1\ArraySuffixEnd}      {0}
    \DefineNewGlobalCounter{#1\ArraySuffixCount}    {0}
}


% Counter names for a given array
\newcommand{\ArrayPosition}[1]{#1\ArraySuffixPosition} % #1 = ArrayName
\newcommand{\ArrayStart}   [1]{#1\ArraySuffixStart}    % #1 = ArrayName
\newcommand{\ArrayEnd}     [1]{#1\ArraySuffixEnd}      % #1 = ArrayName
\newcommand{\ArrayCount}   [1]{#1\ArraySuffixCount}    % #1 = ArrayName
% Counter names for a given array
\newcommand{\ArrayNumberPosition}[1]{\csname#1\ArraySuffixPosition\endcsname}  % #1 = ArrayName
\newcommand{\ArrayNumberStart}   [1]{\csname#1\ArraySuffixStart\endcsname}    % #1 = ArrayName
\newcommand{\ArrayNumberEnd}     [1]{\csname#1\ArraySuffixEnd\endcsname}      % #1 = ArrayName
\newcommand{\ArrayNumberCount}   [1]{\csname#1\ArraySuffixCount\endcsname}    % #1 = ArrayName
% Decrementers
\newcommand{\ArrayDecrementPosition}[1]{\AddToCounter{\ArrayPosition{#1}}{-1}}
\newcommand{\ArrayDecrementStart}   [1]{\AddToCounter{\ArrayStart   {#1}}{-1}}
\newcommand{\ArrayDecrementEnd}     [1]{\AddToCounter{\ArrayEnd     {#1}}{-1}}
\newcommand{\ArrayDecrementCount}   [1]{\AddToCounter{\ArrayCount   {#1}}{-1}}
% Incrementers
\newcommand{\ArrayIncrementPosition}[1]{\AddToCounter{\ArrayPosition{#1}}{+1}}
\newcommand{\ArrayIncrementStart}   [1]{\AddToCounter{\ArrayStart   {#1}}{+1}}
\newcommand{\ArrayIncrementEnd}     [1]{\AddToCounter{\ArrayEnd     {#1}}{+1}}
\newcommand{\ArrayIncrementCount}   [1]{\AddToCounter{\ArrayCount   {#1}}{+1}}
% Numerical values
\newcommand{\ArrayValuePosition}[1]{\CounterValue{#1\ArraySuffixPosition}} % #1 = Array name
\newcommand{\ArrayValueStart}   [1]{\CounterValue{#1\ArraySuffixStart}}    % #1 = Array name
\newcommand{\ArrayValueEnd}     [1]{\CounterValue{#1\ArraySuffixEnd}}      % #1 = Array name
\newcommand{\ArrayValueCount}   [1]{\CounterValue{#1\ArraySuffixCount}}    % #1 = Array name
% Use the array entry given a counter set to the desired index
\newcommand{\ArrayUse}[2]{\csuse{#1\ArraySuffix\CounterValue{#2}}}


\newcommand{\ArrayDelete}[1]{% #1 = Array name
    \ForEach{#1}{
        \MakeCommandUndefined
            {#1\ArraySuffix\CounterValue{ForLoopCounter}}}

    \MakeCommandUndefined{#1\ArraySuffix}
    \MakeCounterUndefined{#1\ArraySuffixPosition}
    \MakeCounterUndefined{#1\ArraySuffixStart}
    \MakeCounterUndefined{#1\ArraySuffixEnd}
    \MakeCounterUndefined{#1\ArraySuffixCount}
}

\newcommand{\ArrayReset}[1]{% #1 = Array name
    \ForEach{#1}{
        \MakeCommandUndefined
            {#1\ArraySuffix\CounterValue{ForLoopCounter}}}

    \SetCounter{#1\ArraySuffixPosition} {0}
    \SetCounter{#1\ArraySuffixStart}    {1}
    \SetCounter{#1\ArraySuffixEnd}      {0}
    \SetCounter{#1\ArraySuffixCount}    {0}
}

\newcommand{\ArrayPush}[2]{% #1 = Array name, #2 value to push

    % increment counters
    \ArrayIncrementCount{#1}
    \ArrayIncrementEnd  {#1}

    % Naming scheme for the Array storage commands: <Name>\roman{<Counter>}
    \MakeCommand{#1\ArraySuffix\ArrayValueEnd{#1}}{#2}%
}

\newcommand{\ArrayPop}[1]{% #1 = Array name
    \ifnum\ArrayNumberCount{#1}>0%
        \ArrayUse{#1}{\ArrayEnd{#1}}%
        \MakeCommandUndefined{#1\ArraySuffix\ArrayValueEnd{#1}}%
        % decrement counters
        \ArrayDecrementCount{#1}%
        \ArrayDecrementEnd  {#1}%
    \fi%
}

\newcommand{\ArrayPopAndStore}[2]{% #1 = Array name, #2 name of command to store the popped value
    \ifnum\ArrayNumberCount{#1}>0%
        \MakeExpandedCommand{#2}{\ArrayUse{#1}{\ArrayEnd{#1}}}%
        \MakeCommandUndefined{#1\ArraySuffix\ArrayValueEnd{#1}}%
        % decrement counters
        \ArrayDecrementCount{#1}
        \ArrayDecrementEnd  {#1}
    \fi
}

\newcommand{\ArrayGet}[2]{% #1 = Array name, % 2 = Counter Name for index
    %\IfArrayExists{#1}%
        %{\IfArrayIndexDefined{#1}{#2}%
            %{
            %\ArrayUse{#1}{#2}}%
        %    {\UWMad@ClassWarning{Index for array '#1' is undefined.}}}%
        %{}%
    \csname#1\ArraySuffix\CounterValue{#2}\endcsname
}

\newcommand{\IfArrayIndexDefined}[4]{% #1 = Array name, % #2 = numeric value, % #3 = True code, % #4 = False code
    \IfCommandExists{#1\ArraySuffix\CounterValue{#2}}%
        {#3}%
        {#4}%
}

\newcommand{\IfArrayIndexNotDefined}[4]{% #1 = Array name, % #2 = numeric value, % #3 = True code, % #4 = False code
    \IfCommandExists{#1\ArraySuffix\CounterValue{#2}}%
        {#4}%
        {#3}%
}%

\newcommand{\IfArrayExists}[3]{% #1 = Array name, #2 = True code, #3 = False code
    \IfCommandExists{#1\ArraySuffix}%
        {#2}%
        {#3}%
}%




% =========================================================================== %
%                 Hashes (Associative Arrays) with LaTeX3                     %
% =========================================================================== %


% ************ LaTeX3 ON ************ %
\ExplSyntaxOn

\DeclareDocumentCommand \HashMake {m}%
    {\prop_new:c {g_UWMad_Hash_#1}}

\DeclareDocumentCommand \HashSet {mmm}%
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}%
      {\prop_gput:cnn   {g_UWMad_Hash_#1}{#2}{#3}}%
        {\HashMake{#1}%
         \prop_gput:cnn {g_UWMad_Hash_#1}{#2}{#3}}}

\DeclareDocumentCommand \HashGet {mm}%
    {\prop_if_exist:cTF  {g_UWMad_Hash_#1}%
        {\prop_get:cn {g_UWMad_Hash_#1} {#2}}
        {}}

\cs_generate_variant:Nn \prop_get:cn {cf}

\DeclareExpandableDocumentCommand \HashExpandableGet {mm}%
    {\prop_if_exist:cTF  {g_UWMad_Hash_#1}%
        {\prop_get:cf {g_UWMad_Hash_#1} {#2}}
        {}}

\DeclareDocumentCommand \HashUnset {mm}%
    {\prop_if_exist:cTF    {g_UWMad_Hash_#1}%
        {\prop_get:cnNTF   {g_UWMad_Hash_#1} {#2} \l_UWMad_Hash_Value_tl%
            {\prop_gdel:cn {g_UWMad_Hash_#1} {#2}}
            {}}}

\DeclareDocumentCommand \IfHashKeySet {mmmm}%
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}%
        {\prop_if_in:cnTF {g_UWMad_Hash_#1} {#2}
            {#3}
            {#4}}
        {}}

\DeclareDocumentCommand \HashDelete {m}%
    {\prop_if_exist:cTF {g_UWMad_Hash_#1}%
        {\prop_gclear:c {g_UWMad_Hash_#1}%
         \cs_undefine:c {g_UWMad_Hash_#1}}
        {}}

\ExplSyntaxOff
% ************ LaTeX3 OFF *********** %






% =========================================================================== %
%                            For-Loop Definition                              %
% =========================================================================== %


% Initilaze the recursive command (see usage below) ----------------------
\newcommand{\ForLoopRecursion}{}

% Define the loop counter ------------------------------------------------
\DefineNewLocalCounter{ForLoopCounter}{0}

% Iterator command -------------------------------------------------------
\newcommand{\For}[4][1]{%
    {%
    % Arguments
    %   #1 = increment (optional)
    %   #2 = start value
    %   #3 = end value
    %   #4 = <code>
    % Redefine the command used for recursion
    \renewcommand{\ForLoopRecursion}{%
        #4%                                         % Excute <code>
        \AddToCounter{ForLoopCounter}{#1}%          % Increment the counter
        \For[#1]{\number\ForLoopCounter}{#3}{#4}%   % Recurse
    }%
    %
    % Set the counter to the start value 
    % After the recursion begins, #2 is the current value of the counter and not the start value.
    \SetCounter{ForLoopCounter}{#2}%
    %
    % Switch to deal with positive vs. negative increments (decrements).
    \ifnum #1 > 0%                                    % If positive increment
        \IfLessThanEqualTo{\ForLoopCounter}{#3}{%     % Execute while the LoopCounter is less than or equal to the end value
            \ForLoopRecursion%
        }{}%
    \else%                                                   % If negative increment
        \IfGreaterThanEqualTo{\ForLoopCounter}{#3}{%   % Execute while the LoopCounter is greater than or equal to the end value
            \ForLoopRecursion%
        }{}%
    \fi%
    }%
}


\newcommand{\ForEach}[3][1]{
% Arguments
%   #1 = increment (optional)
%   #2 = Array/Hash name
%   #3 = <code>
    %
    \IfCommandExists{#2\ArraySuffix}{%
        \For[#1]{\ArrayNumberStart{#2}}{\ArrayNumberEnd{#2}}{#3}%
    }{%
        %\IfCommandExists{#2\HashSuffix}{%
        %    \For[#1]{\ArrayNumberStart{#2\HashSuffixKeys}}{\ArrayNumberEnd{#2\HashSuffixKeys}}{#3}%
        %}{%
            \UWMad@ClassWarning{Could not find Array or Hash named '#2'}%
        %}%
    }%
}
%
%</Module:Programming>
%Verbatim
%</Implementation>