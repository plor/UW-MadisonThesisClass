% =============================================================================================== %
%                        WisconsinThesis Class: Programming Module                                %
% =============================================================================================== %


% This is a convenience command used to define a new length and set its initial value.
% A thin abstraction that declares and intializes dimensions.
\newcommand{\DefineNewLength}[2]{
    \newlength{#1}
    \setlength{#1}{#2}
}

% This is a convenience command used to define a new counter and set its initial value.
% A thin abstraction that declares and intializes lengths.
\newcommand{\DefineNewCounter}[2]{
    \newcounter{#1}
    \setcounter{#1}{#2}
}

% If-switch changes only have block level scope by default.  That is, a \newif that is switched within a block
% reverts to its pre-block state upon exit.  This command creates an if-switch set that has global scope.
\newcommand{\GlobalNewIf}[1]{
    \expandafter\newif\csname if#1Global\endcsname
    \expandafter\def\csname if#1\endcsname{\csname if#1Global\endcsname}
    \expandafter\def\csname#1true\endcsname {\expandafter\global\csname#1Globaltrue\endcsname}
    \expandafter\def\csname#1false\endcsname{\expandafter\global\csname#1Globalfalse\endcsname}
}


% A simple command that acts like LaTeX's \@ifundefined, but I like the eTeX conditional more (in looks and implementation).
% Since it is eTeX, this command will allow for a switch to \@ifundefined if problems arise from non-eTeX users in the future.
\newcommand{\IfCommandExists}[3]{%
    \ifcsname#1\endcsname%
        #2%
    \else%
        #3%
    \fi%
}%


% <= Command - no equivalent in TeX
\newcommand{\IfGreaterThanEqualTo}[4]{
    \ifnum#1>#2
        #3
    \else
        \ifnum#1=#2
            #3
        \else
            #4
        \fi
    \fi
}

% >= Command - no equivalent in TeX
\newcommand{\IfLessThanEqualTo}[4]{
    \ifnum#1<#2
        #3
    \else
        \ifnum#1=#2
            #3
        \else
            #4
        \fi
    \fi
}


% Command combo testing for an empty argument
\newcommand{\UWMad@Empty}{}
\newcommand{\IfEmpty}[3]{
    \ifx #1 \UwMad@Empty
        #2
    \else
        #3
    \fi
}

\newcommand{\IfMatch}[4]{% #1 = left compare, #2 = right compare, #3 = true code, #4 = false code
    \ifx #1 #2
        #3
    \else
        #4
    \fi
}




% A environment that allows for global defintions.
\newenvironment{MakeGlobal}{\globaldefs=1}{\globaldefs=0}


 \newcommand{\Trim}[1]{\ignorespaces#1\unskip} 



% Dynamic command creators.
%
% There are structured versions with proper programming whitespace;
% the 'compactified' versions are coded such that no spurious whitespace is added.
%
%   \newcommand{\MakeCommand}[2]{
%       \expandafter\newcommand\csname #1\endcsname{#2}
%   }
% 
%   \newcommand{\ReMakeCommand}[2]{
%       \expandafter\renewcommand\csname #1\endcsname{#2}
%   }
%
\newcommand{\MakeCommand}[2]{\expandafter\newcommand\csname #1\endcsname{#2}}
\newcommand{\ReMakeCommand}[2]{\expandafter\renewcommand\csname #1\endcsname{#2}}

\newcommand{\MakeCommandGlobal}[2]{\begin{MakeGlobal}\MakeCommand{#1}{#2}\end{MakeGlobal}}


\newcommand{\MakeCommandUndefined}[1]{% #1 = Command name
    \begin{MakeGlobal}\expandafter\let\csname#1\endcsname\UWMad@Undefined\end{MakeGlobal}
}

\newcommand{\MakeCounterUndefined}[1]{% #1 = Counter name
    \MakeCommandUndefined{c@#1}
}



% =========================================================================== %
%                          CSV Creation Commands                              %
% =========================================================================== %

\newcommand{\CSVMake}[3][]{ % #1 = List name, #2 = Token to push on to right

    \@ifundefined{#2}
    {
        \begin{MakeGlobal}
            \MakeCommand{#2}{#3}
            \expandafter\newcommand\csname #2Append\endcsname[1]{\CSVAppend{#2}{##1}}
            \expandafter\newcommand\csname #2Prepend\endcsname[1]{\CSVPrepend{#2}{##1}}
        \end{MakeGlobal}
    }{
        \ifthenelse{\equal{#1}{}}
            {
                \typeout{*** CSV Note: Creation ignored since list already exists. ***}
            }{
                \typeout{*** CSV Note: Overwriting already-created list. ***}
                \ReMakeCommand{#2}{#3}
                \expandafter\renewcommand\csname #2Append\endcsname[1]{\CSVAppend{#2}{##1}}
                \expandafter\renewcommand\csname #2Prepend\endcsname[1]{\CSVPrepend{#2}{##1}}
            }
    }
}

\newcommand{\CSVAppend}[2]{ % #1 = List name, #2 = Token to push on to right

    \@ifundefined{#1}
        {
                \MakeCommand{#1}{#2}
                \expandafter\newcommand\csname #1Append\endcsname[1]{\CSVAppend{#1}{##1}}
                \expandafter\newcommand\csname #1Prepend\endcsname[1]{\CSVPrepend{#1}{##1}}
        }{
            %\begin{MakeGlobal}
                \expandafter\let\expandafter\List\csname #1\endcsname
                \expandafter\def\csname #1\endcsname{\List,#2}
            %\end{MakeGlobal}
        }
}

\newcommand{\CSVPrepend}[2]{ % #1 = List name, #2 = Token to push on to left

    \@ifundefined{#1}
        {
            \MakeCommand{#1}{#2}
            \expandafter\newcommand\csname #1Append\endcsname[1]{\CSVAppend{#1}{##1}}
            \expandafter\newcommand\csname #1Prepend\endcsname[1]{\CSVPrepend{#1}{##1}}
        }{
            \expandafter\global\expandafter\protected@edef\csname #1\endcsname{#2,\csname #1\endcsname}
        }
}




% =========================================================================== %
%                      Array Building Commands                                %
% =========================================================================== %

\DefineNewCounter{ArrayWorkCounter}{0}
\newcommand{\ArraySuffix}         {ARRAY}
\newcommand{\ArraySuffixStart}    {\ArraySuffix START   }
\newcommand{\ArraySuffixEnd}      {\ArraySuffix END     }
\newcommand{\ArraySuffixPosition} {\ArraySuffix POSITION}
\newcommand{\ArraySuffixCount}    {\ArraySuffix COUNT   }

\newcommand{\ArrayMake}[1]{% #1 = Array name
    \MakeCommandGlobal{#1\ArraySuffix}        {#1\ArraySuffix}
    \DefineNewCounter{#1\ArraySuffixPosition} {0}
    \DefineNewCounter{#1\ArraySuffixStart}    {1}
    \DefineNewCounter{#1\ArraySuffixEnd}      {0}
    \DefineNewCounter{#1\ArraySuffixCount}    {0}
}


% Counter names for a given array
\newcommand{\ArrayPosition}[1]{#1\ArraySuffixPosition} % #1 = ArrayName
\newcommand{\ArrayStart}   [1]{#1\ArraySuffixStart}    % #1 = ArrayName
\newcommand{\ArrayEnd}     [1]{#1\ArraySuffixEnd}      % #1 = ArrayName
\newcommand{\ArrayCount}   [1]{#1\ArraySuffixCount}    % #1 = ArrayName

% Counter values for a given array
\newcommand{\ArrayValuePosition}[1]{\value{#1\ArraySuffixPosition}} % #1 = Array name
\newcommand{\ArrayValueStart}   [1]{\value{#1\ArraySuffixStart}}    % #1 = Array name
\newcommand{\ArrayValueEnd}     [1]{\value{#1\ArraySuffixEnd}}      % #1 = Array name
\newcommand{\ArrayValueCount}   [1]{\value{#1\ArraySuffixCount}}    % #1 = Array name


\newcommand{\ArrayClear}[1]{% #1 = Array name
    \ForEach{#1}{
        \MakeCommandUndefined{#1\roman{ForLoopCounter}}
    }
    \MakeCommandUndefined{#1\ArraySuffix}
    \MakeCounterUndefined{#1\ArraySuffixPosition}
    \MakeCounterUndefined{#1\ArraySuffixStart} 
    \MakeCounterUndefined{#1\ArraySuffixEnd}   
    \MakeCounterUndefined{#1\ArraySuffixCount} 
}

\newcommand{\ArrayReset}[1]{% #1 = Array name
    \ForEach{#1}{
        \MakeCommandUndefined{#1\roman{ForLoopCounter}}
    }
    \setcounter{#1\ArraySuffixPosition} {0}
    \setcounter{#1\ArraySuffixStart}    {1}
    \setcounter{#1\ArraySuffixEnd}      {0}
    \setcounter{#1\ArraySuffixCount}    {0}
}

\newcommand{\ArrayPush}[2]{% #1 = Array name, #2 value to push

    % increment counters
    \addtocounter{#1\ArraySuffixCount}{1}
    \addtocounter{#1\ArraySuffixEnd}  {1}

    % Naming scheme for the Array storage commands: <Name>\roman{<Counter>}
    \MakeCommand{#1\roman{#1\ArraySuffixEnd}}{#2}
}

\newcommand{\ArrayPop}[1]{% #1 = Array name
    \ifnum\ArrayValueCount{#1}>0
        \csname #1\roman{#1\ArraySuffixEnd}\endcsname
        \addtocounter{#1\ArraySuffixCount}    {-1}
        \addtocounter{#1\ArraySuffixEnd}      {-1}
    \fi
}

\newcommand{\ArrayPopAndStore}[2]{% #1 = Array name, #2 name of command to store the popped value
    \ifnum\value{#1\ArraySuffixCount}>0
        \protected@edef\PoppedValue{\csname #1\roman{#1\ArraySuffixPosition}\endcsname}
        \MakeCommand{#2}{\PoppedValue}
        \addtocounter{#1\ArraySuffixCount}    {-1}
        \addtocounter{#1\ArraySuffixEnd}      {-1}
    \fi
}

\newcommand{\ArrayGet}[2]{% #1 = Array name, % 2 = Counter Name for index
    \IfGreaterThanEqualTo{\value{#2}}{\ArrayValueStart{#1}}{%
        \IfLessThanEqualTo{\value{#2}}{\ArrayValueEnd{#1}}{%
            \csname#1\roman{#2}\endcsname%
        }{%
            \UWMad@ClassWarning{Index to Array '#1' is outside its bounds.}%
        }%
    }{%
        \UWMad@ClassWarning{Index to Array '#1' is below its bounds.}%
    }%
}





% =========================================================================== %
%                Hash (Associative Arrays) Creation Commands                  %
% =========================================================================== %
\newcommand{\HashSuffix}{HASH}

\newcommand{\HashMake}[1]{% #1 = Hash name
    \IfCommandExists{#1\HashSuffix}{
        \UWMad@ClassWarning{Hash '#1' already exists.}
    }{
        \DefineNewCounter{#1\HashSuffix}{0}
        \MakeCommand{#1\HashSuffix}{}
        \ArrayMake{#1\HashSuffix}
    }
}

\newcommand{\HashSet}[3]{% #1 = hash name, #2 = key name, #3 = value

    \IfCommandExists{#1\HashSuffix}{}{
        \HashMake{#1}   % If it doesn't exist, make it.
    }

    \IfCommandExists{#1#2\HashSuffix}{
        \ReMakeCommand{#1#2\HashSuffix}{#3} % Only need to remake the command.
    }{
        \ArrayPush{#1\HashSuffix}{#2}                           % Push key to Array storing all keys for this hash
        \def\ThisHashKeysIndex{\ArrayPosition{#1\HashSuffix}}   % Local: index in Array associated with the key
        \def\ThisHashKeysSuffix{\Roman{\ThisHashKeysIndex}}     % Local: Suffix appended to look-up command for this key
        
        \MakeCommand{#1#2\ThisHashKeysSuffix}{\HashKeyToIndex}  % Command storing the keys index in the array
        \MakeCommand{#1#2\HashSuffix}{#3}                       % Command storing the value assoicated with the key
    }
}

\newcommand{\HashGet}[2]{% #1 = hash name, #2 = key name
    \IfCommandExists{#1\HashSuffix}{%
        \IfCommandExists{#1#2\HashSuffix}{%
            \csname#1#2\HashSuffix\endcsname%
        }{%
            \UWMad@ClassWarning{There is no key '#2' set for hash '#1'}%
        }%
    }{%
        \UWMad@ClassWarning{Hash '#1' does not exist}%
    }%
}%








% =========================================================================== %
%                            For-Loop Definition                              %
% =========================================================================== %


% Initilaze the recursive command (see usage below) ----------------------
\newcommand{\ForLoopRecursion}{}

% Define the loop counter ------------------------------------------------
\newcounter{ForLoopCounter}
\setcounter{ForLoopCounter}{0}

% Iterator command -------------------------------------------------------
\newcommand{\For}[4][1]{%
    % Arguments
    %   #1 = increment (optional)
    %   #2 = start value
    %   #3 = end value
    %   #4 = <code>
    % Redefine the command used for recursion
    \renewcommand{\ForLoopRecursion}{%
        #4%                                         % Excute <code>
        \addtocounter{ForLoopCounter}{#1}%          % Increment the counter
        \For[#1]{\value{ForLoopCounter}}{#3}{#4}%   % Recurse
    }%
    %
    % Set the counter to the start value 
    % After the recursion begins, #2 is the current value of the counter and not the start value.
    \setcounter{ForLoopCounter}{#2}%
    %
    % Switch to deal with positive vs. negative increments (decrements).
    \ifnum #1 > 0                                           % If positive increment
        \IfLessThanEqualTo{\value{ForLoopCounter}}{#3}{     % Execute while the LoopCounter is less than or equal to the end value
            \ForLoopRecursion%
        }{}%
    \else%                                                   % If negative increment
        \IfGreaterThanEqualTo{\value{ForLoopCounter}}{#3}{   % Execute while the LoopCounter is greater than or equal to the end value
            \ForLoopRecursion%
        }{}%
    \fi%
}


\newcommand{\ForEach}[3][1]{
% Arguments
%   #1 = increment (optional)
%   #2 = Array/Hash name
%   #3 = <code>
    %
    \IfCommandExists{#2\ArraySuffix}{%
        \For[#1]{\ArrayValueStart{#2}}{\ArrayValueEnd{#2}}{#3}%
    }{%
        \IfCommandExists{#2\HashSuffix}{%
            \For[#1]{\ArrayValueStart{#2\HashSuffix}}{\ArrayValueEnd{#2\HashSuffix}}{#3}%
        }{%
            \UWMad@ClassWarning{Could not find Array or Hash named '#2'}%
        }%
    }%
}







